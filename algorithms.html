<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
<head>

    <!-- for sort animation -->
    <link rel="stylesheet" href="Algocynfas/lib/bootstrap.min.css">
    <link rel="stylesheet" href="Algocynfas/userInterface.css">
    <script src="Algocynfas/lib/bootstrap.min.js"></script>
    <script src="Algocynfas/lib/fabric.js"></script>
    <script src="Algocynfas/algocynfas.js"></script>
    <script src="Algocynfas/widgets.js"></script>
    <script src="Algocynfas/sort.js"></script>



        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
    <title>
        Algorithms
    </title>
</head>

<body>

    <div id="header">
        <div id="logo">
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/250px-6n-graf.svg.png"
            height="56" width="84"
            max-height=100%>
        </div>
        <div id="user-tools">
            <a href="index.html">Home</a>
            &nbsp; &nbsp; 
            <a href="about.html">About</a>
        </div>
    </div>


    <h1 class="chap-title">
        Algorithms
    </h1>
    <div style="text-align:center">
        <figure class="lead-figure">
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Sorting_quicksort_anim.gif/220px-Sorting_quicksort_anim.gif">
        </figure>
    </div>

    <details>
        <summary class="sum1">
         Algorithms 
     </summary>
     <details>
        <summary class="sum2">
            Overview
        </summary>
        <p>
         An <b>algorithm</b> is a finite
         sequence of precise instructions 
         for performing a computation or for solving a problem.
     </p>

     <p>
         Algorithm for finding the maximum (largest) value in a finite 
         sequence of integers:
         Solution Steps:
     </p>

     <ol class="nested">
        <li>
            Set the temporary maximum equal 
            to the first integer in 
            the sequence.
        </li>
        <li>
            Compare the next integer in the 
            sequence to the temporary 
            maximum, and if it is larger than the 
            temporary maximum, set the 
            temporary maximum equal to this integer.
        </li>
        <li>
            Repeat the previous step if there 
            are more integers in the
            sequence.
        </li>
        <li>
            Stop when there are no integers 
            left in the sequence. 
            The temporary maximum at this point 
            is the largest integer in 
            the sequence.
        </li>
    </ol>
    <p>
      Properties of an Algorithm
  </p>

  <ol class="nested">
    <li>
        Input
    </li>
    <li>
        Output
    </li>
    <li>
        Definitiveness
    </li>
    <li>
        Correctness
    </li>
    <li>
        Finiteness
    </li>
    <li>
        Effectiveness
    </li>
    <li>
        Generality
    </li>
</ol>
</details>
<details>
    <summary class="sum2">
        Searching Algorithms 
    </summary>
    <p>
        The problem of locating an element 
        in an ordered list occurs in 
        many contexts. For instance, a program 
        that checks the spelling of 
        words searches for them in a dictionary, 
        which is just an ordered 
        list of words. Problems of this kind are 
        called searching problems.
    </p>

    <details>
        <summary class="sum3">
            Linear Search
        </summary>
        <figure>
            <img src="https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif" 
            alt="Linear Search Animation">
        </figure>
        <p>
            <b>procedure</b> <i>linear search(x</i>: integer,
            <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, .
            . . , <i>a<sub>n</sub></i>: distinct integers)<br>
            <i>i := 1</i><br>
            <b>while</b> (<i>i</i> &le; <i>n</i> 
            and <i>x</i> != <i>a</i>[<i>i</i>] )<br>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            <i>i</i> = <i>i</i> + 1
            <br>
            <b>if</b> <i>i</i> &le; <i>n</i> <b>then</b>
            <i>location</i> := <i>i</i><br>
            <b>else</b> <i>location</i> := 0
            <br>
            <b>return</b> <i>location</i> 
            {<i>location</i> is the subscript of 
                the term that equals <i>x</i>,
                or is 0 if <i>x</i> is not found}
            </p>

        </details>
        <details>
            <summary class="sum3">
                Binary Search
            </summary>
            <p>
             This algorithm can be used when 
             the list has terms occurring in 
             order of increasing size (for instance: 
             if the terms are numbers, 
             they are listed from smallest to largest; 
             if they are words, they 
             are listed in lexicographic, or alphabetic, 
             order). This second 
             searching algorithm is called the binary search algorithm.
             <br>
         </p>

         <figure>
            <img 
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_0.jpg">
            <br>
            <img 
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_1.jpg">
            <br>
            <img
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_2.jpg">
            <br>
            <img 
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_3.jpg">
            <br>
            <img
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_4.jpg">
            <br>
            <img
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_5.jpg">
            <br>
            <img
            src = "https://www.tutorialspoint.com/data_structures_algorithms/images/binary_search_6.jpg">
        </figure>
    </details>  

</details>
<details>
    <summary class="sum2">
     Sorting Algorithms
 </summary>
 <details>
    <summary class="sum3">
        Bubble Sort
    </summary>
    <figure>
        <img src="http://www.opentechguides.com/images/howto/howto_5101.png">
    </figure>
    <p>
        <b>Psuedocode</b>
        <br>
    </p>
    <p>
     <code>
         <pre>

            <b>procedure</b> <i>bubblesort</i>(<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, . . . , <i>a<sub>n</sub></i>: real numbers n &ge; 2)
            <b>for</b> ( <i>i := 1</i> to <i>n</i>-1)
            <b>for</b> ( <i>j</i> to <i>n</i>-1)
            <b>if</b> <i>a</i> <sub> <i>j</i></sub> &gt; <i>a</i><sub><i>j</i>+1</sub> <b>then</b> interchange <i>a</i><sub><i>j</i></sub> and <i>a</i><sub><i>j</i>+1</sub><br>
            {<i>a</i><sub>1</sub>, . . . ,<i>a</i> <sub>n</sub> is in increasing order}
        </pre>
    </code>
</p>

</details>
<details>
    <summary class="sum3">
        Insertion Sort
    </summary>

    <p>
     <b>procedure</b>
     <b>insertionsort</b>(<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, .
     . . , <i>a</i><sub><i>n</i></sub>: real numbers <i>n </i>&ge; 2)<br>
     &nbsp; &nbsp; &nbsp; <b>for</b> ( <i>j := 2</i> to <i>n</i>)<br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>i</i> :&equals; 1 <br>

     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <b>while</b> <i>a</i> <sub> <i>j</i></sub> &gt;
     <i>a</i><sub><i>i</i></sub> <br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;
     <i> i</i> :&equals; <i>i</i>+1<br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>m</i> :&equals; <i>a</i><sub><i>j</i></sub> <br>
     &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;
     <b>for</b> <i>k</i> :&equals; 0 to <i>j</i> &minus; <i>i</i> &minus; 1 <br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>a</i><sub><i>j</i></sub><sub>&minus;</sub><sub><i>k</i></sub>
     :&equals;  <i>a</i><sub><i>j</i></sub>
     <sub>&minus;</sub><sub><i>k</i></sub>
     <sub> &minus; 1</sub> <br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>a</i><sub><i>i</i></sub> :&equals; <i>m</i> <br>
     &nbsp; &nbsp; &nbsp;{<i>a</i><sub>1</sub>, . . . ,
     <i>a</i><sub><i>n</i></sub>}
 </p> 
</details>

<details>
    <summary class="sum3">
        Try Sorting Algorithms
    </summary>
    <div class="container" style = "margin-left: 5em">
           <b> Sort Types: 

           <input type="radio" name="sort" id="insertion" checked = "true"/>
           <label for="insertion">Insertion Sort</label>

           <input type="radio" name="sort" id="bubble"/>
           <label for="bubble">Bubble Sort</label>

           <input type="radio" name="sort" id="quick"/>
           <label for="quick">Quick Sort</label>

           <br>
           </b>
           <b>Choose Speed:

           <input type="radio" name="speed" value="500" id="Fast"/> 
           <label for="Fast">Fast</label>
           <input type="radio" name="speed" value="1000" id="Medium" checked="true"/>
           <label for="Medium">Medium</label>
           <input type="radio" name="speed" value="2000" id="Slow"/> 
           <label for="Slow">Slow</label>

            <br>
            </b>

            <b>
            Fill the input box with sample values:
            </b>
                <select id= sortSample onchange="setSortSample()">
                <option value="Select" >Select one</option>
                <option value="sample1" >More random input </option>
                <option value="sample2"> More sorted input </option>
              </select>


            <br>
            <br>
           
       

            <input type="text" class="inputbox" id="number-input" 
            placeholder="Enter a list of Integers between -99 to 99 separate by comma" 
            aria-label="Enter a list of Integers between -99 to 99 separate by comma" style="width: 30em">
           
                <button class="btn btn-primary" id="add-number-button" type="button" 
                onclick="inputNumberToArray()">Create a List
               </button>
          <br>
       <button id = "run-button" type="button" class="btn btn-success col-1" onclick="run()">Run</button>
                 
  
       
 &emsp;&emsp;&emsp;
           <button id = "stop-button" type="button" class="btn btn-danger col-1" onclick="stopAnime()">Stop</button>
           <br>
           <br>

           
         
<canvas id="canvas" width="800" height="144"
style="border:0.1em solid #000000"></canvas>
<script>
const numbersGroup = document.getElementsByClassName("numbers-group")[0];
let canvas = new fabric.Canvas('canvas');
let list = [];
let fList = null;
drawListOnScreen(list);
</script>
<footer id="sortLegend">
        <script> window.display_legend("sortLegend", "Item Swapped", "Item being Compared") </script>
 </footer>
    </div>
</details>

</details>
<details>
    <summary class="sum2">
        Greedy Algorithms
    </summary>
    <p>
        Algorithms that make what seems to be the best
        choice at each step are called <b>greedy algorithms.</b>
        <br>
        <b>Greedy Change-Making Algorithm</b>
        <br>
    </p>

    <p>
     <b>procedure</b>
     <b>change</b>(<i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>, .
     . . , <i>c</i><sub><i>n</i></sub>: value of denominations
     where <i>c</i><sub>1</sub> &gt; <i>c</i><sub>2</sub> &gt; .
     . . , <i>c</i><sub><i>n</i></sub> : <i>n </i> is a positive
     integer)<br>
     &nbsp; &nbsp; &nbsp; <b>for</b> ( <i>i := 1</i> to <i>r</i>)<br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>d</i><sub>i</sub> :&equals; 0 {<i>d</i><sub>i</sub>
     counts the number of denominations <i>c</i><sub>i</sub>
     used <br>

     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <b>while</b> <i>n</i>  &ge;
     <i>c</i><sub><i>i</i></sub> <br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>d</i><sub>i</sub> :&equals; <i>d</i><sub>i</sub> +
     1 {add a coin of denomination <i>c</i><sub>i</sub> } <br>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
     <i>n</i> :&equals; <i>n</i> -  <i>c</i><sub><i>i</i></sub> <br>
     <i>d</i><sub><i>i</i></sub> is the number of coins of
     denominations in  <i>c</i><sub>i</sub> in change for
     <i>i</i> &equals; 1, 2, 3 <br>
 </p>
 <p class="def">
    LEMMA 1
</p>

<p>
    If n is a positive integer, 
    then <i>n</i> cents in change using 
    quarters, dimes, nickels, and pennies 
    using the fewest coins possible 
    has at most two dimes, at most one nickel, 
    at most four pennies, and 
    cannot have two dimes and a nickel. 
    The amount of change in dimes, 
    nickels, and pennies cannot exceed 24 cents.
</p>

<p class="def">
 THEOREM 1
</p>

<p>
    The greedy algorithm produces change using the 
    fewest coins possible.
    <br>
</p>

<p>
    <b>Greedy Algorithm for Scheduling Talks</b>
</p>

<p>
 <b>procedure</b>
 <b>schedule</b>(<i>s</i><sub>1</sub> &le;
 <i>s</i><sub>2</sub> &le; .
 . . , <i>s</i><sub><i>n</i></sub>: start time of talks <br>
 <i>e</i><sub>1</sub> &le; <i>e</i><sub>2</sub> &le; .
 . . , <i>e</i><sub><i>n</i></sub> : <i>n </i> ending times
 of talks)<br>
 sort talks by finish time and reorder so that <i>e</i><sub>1</sub> &le; 
 <i>e</i><sub>2</sub> &le; . . , <i>e</i><sub><i>n</i></sub>
 <br>
 &nbsp; &nbsp; &nbsp; S :&equals; 0<br>
 &nbsp; &nbsp; &nbsp; <b>for</b> ( <i>i := 1</i> to <i>n</i>)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 if talk j is compatible with S <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp;
 S :&equals; S &union; {talk j} <br>
 &nbsp; &nbsp; &nbsp; return S{ S is the set of talks produced}
 <br>
</p>
</details>

<details>
    <summary class="sum2">
        The Halting Problem
    </summary>
    <p>
        <b>The Halting Problem is Unsolvable</b><br>
    </p>

    <figure>
        <img src="graphics/HaltingProblem.svg.png">
    </figure>
    <p>
        <a href="http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html">
            Scooping the Loop Snooper
        </a>
    </p>


</details>
    <details>
        <summary class="sum2">
            Test Yourself!
        </summary>
        <ol class="nested">
            <li>
                What is an algorithm?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q1" value="a">
                None of above
                </li>
                <li>
                <input type="radio" name="q1" value="b">
                A function executing a task to solve a problem
                </li>
                <li>
                <input type="radio" name="q1" value="c">
                1.    Finite sequence of precise instructions for performing a computation or for solving a problem.
                </li>
                <li>
                <input type="radio" name="q1" value="d">
                A excerpt of code that can be run induvidually to perform computation
                </li>
            </ol>
            <li>
                Which of these is a property of an algorithm
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q2" value="a">
                All of them
                </li>
                <li>
                <input type="radio" name="q2" value="b">
                Effectiveness
                </li>
                <li>
                <input type="radio" name="q2" value="c">
                Finiteness
                </li>
                <li>
                <input type="radio" name="q2" value="d">
                Definitiveness
                </li>
            </ol>
            <li>
                The minimum runtime for a linear and binary search algorithm?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q3" value="a">
                O(n), O(n)
                </li>
                <li>
                <input type="radio" name="q3" value="b">
                O(n), O(log n)
                </li>
                <li>
                <input type="radio" name="q3" value="c">
                O(log),O(n)
                </li>
                <li>
                <input type="radio" name="q3" value="d">
                O(log n), O(log n)
                </li>
            </ol>
            <li>
                Bubble sort is a type of:
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q4" value="a">
                Algorithm with highest space complexity
                </li>
                <li>
                <input type="radio" name="q4" value="b">
                Brute-Force algorithm
                </li>
                <li>
                <input type="radio" name="q4" value="c">
                Optimized Algorithm
                </li>
                <li>
                <input type="radio" name="q4" value="d">
                An algorithm that works only on positive numbers
                </li>
            </ol>
            <li>
                Insertion Sort has lower running time as compared to bubble sort?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q5" value="a">
                False
                </li>
                <li>
                <input type="radio" name="q5" value="b">
                True
                </li>
            </ol>
            <li>
                Greedy algorithms are also used widely in memory management. Given a list of blocks, in which the sizes are { 100, 150, 180, 200, 300 }, how would a greedy algorithm (grab the smallest block that works first) fit processes with sizes {10, 222, 198, 147, 178 }?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q6" value="a">
                process 1: block 1, process 2: block 5, process 3: block 4, process 4: block 3, process 5: block 2
                </li>
                <li>
                <input type="radio" name="q6" value="b">
                process 1: block 5, process 2: block 2, process 3: block 4, process 4: block 3, process 5: block 1
                </li>
                <li>
                <input type="radio" name="q6" value="c">
                process 1: block 1, process 2: block 2, process 3: block 4, process 4: block 3, process 5: block 5
                </li>
                <li>
                <input type="radio" name="q6" value="d">
                process 1: block 1, process 2: block 5, process 3: block 4, process 4: block 2, process 5: block 3
                </li>
            </ol>
            <li>
                An example of set of coin denominations for which the greedy algorithm does not yield an optimal solution for change of 6 is
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q7" value="a">
                { 1, 3, 3}
                </li>
                <li>
                <input type="radio" name="q7" value="b">
                { 1, 4, 2}
                </li>
                <li>
                <input type="radio" name="q7" value="c">
                { 1, 3, 4 }
                </li>
            </ol>
            <li>
                Binary search only works on sorted array whereas linear search works on sorted as well as unsorted array.
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q8" value="a">
                False
                </li>
                <li>
                <input type="radio" name="q8" value="b">
                True
                </li>
            </ol>
            <li>
                You need to have complete array into memory for linear search but binary search reduces the in-memory usage.
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q9" value="a">
                True
                </li>
                <li>
                <input type="radio" name="q9" value="b">
                False
                </li>
            </ol>
        </ol>
        <details>
            <summary class="sum3">
                Answers
            </summary>
            <p>
                1. c; 2. a; 3. b; 4. b; 5. a; 6. d; 7. c; 8. b; 9. a; 
            </p>
        </details>
    </details>
    </details>
    <details>
        <summary class="sum1">
            The Growth of Functions 
        </summary>
        <details>
            <summary class="sum2">
                Big-O Notation
            </summary>

            <p class="def">
                DEFINITION
            </p>

            <p>
                Let <i>f</i> and <i>g</i> be functions 
                from the set of integers
                or the set of real numbers to the set 
                of real numbers.We say that 
                <i>f</i>(<i>x</i>) is <i>O</i>(<i>g</i>(<i>x</i>)) if 
                there are constants <i>C</i> and 
                <i>k</i> such that |<i>f</i>(<i>x</i>)| 
                &le; <i>C</i>|<i>g</i>(<i>x</i>)|whenever 
                <i>x</i> &gt; <i>k</i>.
                <br>
                (This is read as "<i>f</i>(<i>x</i>)
                is big-oh of <i>g</i>(<i>x</i>).")
                <br>
                <b>Example 1 </b>
                Show that 
                <i>f</i>(<i>x</i>) = 7<i>x</i><sup>2</sup> is
                O(<i>x</i><sup>3</sup>).
                Take <i>C</i> = 1 and <i>k</i> 
                = 7 as witnesses to establish
                that 7<i>x<sup>2</sup></i>  
                is <i>O</i>(<i>x</i><sup>3</sup>).
                <br>
                When <i>x</i> &gt; 7, 
                7<i>x</i><sup>2</sup> &lt; <i>x</i><sup>3</sup>.
                <br>
                Consequently, we can take 
                <i>C</i>= 1 and <i>k</i> = 7 as
                witnesses to establish the 
                relationship 7<i>x</i><sup>2</sup> is
                O(<i>x</i><sup>3</sup>).
                <br>
                Alternatively, when <i>x</i> 
                &gt; 1, we have 7<i>x</i><sup>2</sup> &lt;
                7<i>x</i><sup>3</sup>, 
                so that <i>C</i> = 7
                and <i>k</i> = 1 are also
                witnesses to the relationship
                7<i>x</i><sup>2</sup> is <i>O</i>(<i>x</i><sup>3</sup>).
            </p>

        </details>
        <details>
            <summary class="sum2">
                Big-O Estimates for Some Important Functions
            </summary>
            <p class="def">
                THEOREM 1
            </p>

            <p>
                Let <i>f</i>(<i>x</i>) =
                <i>a</i><sub><i>n</i></sub>
                <i>x</i><sup><i>n</i></sup> +
                <i>a</i><sub><i>n</i> &minus;
                    1</sub><i>x</i><sup><i>n</i>
                   &minus; 1</sup> +...+ 
                <i>a<sup>x</sup></i> + <i>a</i>, 
                where <i>a</i><sub>0</sub>, 
                <i>a</i><sub>1</sub>...
                <i>a</i><sub><i>n</i> &minus; 1</sub>, 
                <i>a</i><sub><i>n</i></sub> are real numbers.
                Let <i>f</i>(<i>x</i>) =
                <i>a</i><sub><i>n</i></sub><i>x</i><sup><i>n</i></sup> +
                <i>a</i><sub><i>n</i> &minus;
                    1</sub><i>x</i><sup>n &minus;1</sup>
                +...+ <i>a</i><i>x</i> + <i>a</i>,
                where <i>a</i><sub>0</sub>, 
                <i>a</i><sub>1</sub>...
                <i>a</i><sub><i>n</i> &minus; 1</sub>, 
                <i>a</i><sub><i>n</i></sub> are real numbers.
                <br>
                Then <i>f</i>(<i>x</i>) is
                <i>O</i>(<i>x</i><sup><i>n</i></sup>).
                <br>
                <b>A Display of the Growth 
                of Functions Commonly Used in Big-O
                Estimates.</b>
                <br>
            </p>

            <figure>
                <img src="graphics/BigOEstimates.svg.png">
            </figure>
        </details>
        <details>
            <summary class="sum2">
                The Growth of Combinations of Functions
            </summary>
            <p class="def">
                THEOREM 2
            </p>

            <p>
                Suppose that <i>f</i><sub>1</sub>(<i>x</i>) is
                <i>O(g</i><sub>1</sub>(<i>x</i>)) and that 
                <i>f</i><sub>2</sub>(<i>x</i>) 
                is <i>O(g</i><sub>2</sub>(<i>x</i>)).<br> 
                Then (<i>f</i><sub>1</sub>  
                + <i>f</i><sub>2</sub>)
                (<i>x</i>) is <i>O</i>
                (max(|<i>g</i><sub>1</sub>
                (<i>x</i>)|, |<i>g</i><sub>2</sub>(<i>x</i>)|)).
            </p>

            <p class="def">
                COROLLARY 1
            </p>

            <p>
                Suppose that <i>f</i><sub>1</sub>(<i>x</i>) and 
                <i>f</i><sub>2</sub>(<i>x</i>) 
                are both <i>O</i>(<i>g</i>(<i>x</i>)).
                <br>
                Then (<i>f</i><sub>1</sub> + 
                <i>f</i><sub>2</sub>)(<i>x</i>) is 
                <i>O</i>(<i>g</i>(<i>x</i>)).
            </p>

            <p class="def">
                THEOREM 3
            </p>

            <p>
                Suppose that <i>f</i><sub>1</sub>(<i>x</i>)
                is <i>O</i>(<i>g</i><sub>1</sub>(<i>x</i>)) 
                and <i>f</i><sub>2</sub>(<i>x</i>) 
                is <i>O(g</i><sub>2</sub>(<i>x</i>)).
                <br>
                Then (<i>f</i><sub>1</sub><i>f</i><sub>2</sub>)
                (<i>x</i>) is 
                <i>O(g</i><sub>1</sub>(<i>x)g</i><sub>2</sub>(<i>x</i>)).
            </p>

        </details>
        <details>
            <summary class="sum2">
                Big-Omega and Big-Theta Notation
            </summary>
            <p class="def">
                DEFINITION 2
            </p>

            <p>
                Let <i>f</i> and <i>g</i> be 
                functions from the set of integers 
                or the set of real numbers to 
                the set of real numbers.We say that 
                <i>f</i>(<i>x</i>) is <i>&#937</i>;
                (<i>g</i>(<i>x</i>) if there are positive constants 
                <i>C</i> and <i>k</i> such that |<i>f</i>(<i>x</i>)| &ge; 
                <i>C</i>|<i>g</i>(<i>x</i>)|
                whenever <i>x</i> &gt; <i>k</i>.
                <br>
                (This is read as "<i>f</i>(<i>x</i>
                is big-Omega of <i>g</i>(<i>x</i>.")
                <br>
                <b>Example: </b>Show that 
                <i>f</i>(<i>x</i>) = <i>x<sup>3</sup></i> is 
                &Omega;(7<i>x</i><sup>2</sup>).
                <ul class="nested">
                    <li>
                        In the above example we have 
                        proved the exact opposite.
                    </li>
                    <li>
                        Consider the same witness <i>C</i> =1
                        and <i>k</i> = 7 to establish this relation
                    </li>
                    <li>
                        Just by turning in inequality,
                        we can say that f(x) is &Omega;
                        (7<i>x</i><sup>2</sup>)
                        we can say that <i>f</i>(<i>x</i> is 
                        &Omega;(7<i>x</i><sup>2</sup>)
                    </li>
                </ul>
            </p>

            <p class="def">
                DEFINITION 3
            </p>

            <p> 
                Let <i>f</i> and <i>g</i> be 
                functions from the set of integers 
                or the set of real numbers to 
                the set of real numbers.We say that
                <i>f</i>(<i>x</i>) is <i>&theta;</i>(<i>g</i>(<i>x</i>))
                if <i>f</i>(<i>x</i>) is <i>O</i>(<i>g</i>(<i>x</i>) 
                and <i>f</i>(<i>x</i>) is <i>&#937;(</i><i>g</i>(<i>x</i>)). 
                When <i>f</i>(<i>x</i>)is 
                <i>&#920;(<i>g</i>(<i>x</i>))</i> we say that <i>f</i> 
                is big-Theta of <i>g</i>(<i>x</i>), 
                that <i>f</i>(<i>x</i>) is of order <i>g</i>(<i>x</i>), 
                and that <i>f</i>(<i>x</i>) and 
                <i>g</i>(<i>x</i>) are of the same order.
                <br>
                <b>Example:</b> Show that 3<i>x</i><sup>2</sup>+ 8<i>x</i> 
                log <i>x</i> is &Theta;(<i>x</i><sup>2</sup>).
            </p>

            <ul class="nested">
                <li>
                   Because 0 &le; 8<i>x</i> log 
                   <i>x</i> &le; 8<i>x</i><sup>2</sup>, 
                   it follows that 3<i>x</i><sup>2</sup> 
                   + 8<i>x</i> log <i>x</i> 
                   &le; 11<i>x</i><sup>2</sup> for <i>x</i> &gt; 1.
                </li>
                <li>
                    Consequently, 3<i>x</i><sup>2</sup> 
                    + 8<i>x</i> log <i>x</i> is 
                    O(<i>x</i><sup>2</sup>). 
                </li>
                <li>
                    Clearly, <i>x</i><sup>2</sup> is
                    O(3<i>x</i><sup>2</sup> + 8<i>x</i> 
                    log <i>x</i>).
                    Let <i>f</i> and <i>g</i> be 
                    functions from the set of integers 
                    or the set of real numbers to the set 
                    of real numbers.We say that
                    <i>f(x)</i> is <i>&#920;(g(x))</i> if 
                    <i>f(x)</i> is <i>O(g(x))</i> 
                    and <i>f(x) </i>is <i>&#937;(g(x))</i>. 
                    When <i>f(x)</i> is 
                    <i>&#920;(g(x))</i> we say that <i>f</i>
                    is big-Theta of <i>g(x)</i>, 
                    that <i>f(x)</i> is of order <i>g(x)</i>, 
                    and that <i>f(x)</i> and 
                    <i>g(x)</i> are of the same order.
                    <br>
                    <b>Example:</b> Show that 3<i>x<sup>2</sup></i> + 8<i>x</i> 
                    log <i>x</i> is &Theta;(<i>x</i><sup>2</sup>).
                </li>
            </ul>

            <ul class="nested">
                <li>
                    Because 0 &le; 8<i>x</i> log <i>x</i>
                    &le; 8<i>x<sup>2</sup></i>, 
                    it follows that 3<i>x<sup>2</sup></i>
                    + 8<i>x</i> log <i>x</i> 
                    &le; 11<i>x<sup>2</sup></i> for <i>x</i> &gt; 1.
                </li>
                <li>
                   Consequently, 3<i>x<sup>2</sup></i>
                   + 8<i>x</i> log <i>x</i> is 
                   O(<i>x<sup>2</sup></i>). 
                </li>
                <li>
                    Clearly, <i>x</i><sup>2</sup> is
                    O(3<i>x</i><sup>2</sup> + 8<i>x</i> log <i>x</i>).
                </li>
                <li>
                    Consequently, 3<i>x</i><sup>2</sup> + 
                    8<i>x</i> log <i>x</i> is
                    <i>&Theta;(x</i><sup>2</sup>).
                </li>
            </ul>
            <p class="def">
                THEOREM 4
            </p>

            <p>
                Let <i>f</i>(<i>x</i>) =
                <i>a</i><sub><i>n</i></sub>x<sup><i>n</i></sup> +
                <i>a</i><sub><i>n</i>-1</sub><i>x</i><sup><i>n</i> &minus;
                    1</sup>
                +...+ <i>a</i><sub>1</sub>
                + <i>a</i><sub>0</sub>, where <i>a</i><sub>0</sub>,
                <i>a</i><sub>1</sub>, . . . , 
                an are real numbers
                with <i>a</i><sub><i>n</i></sub> &ne; 0.
                <i>a</i><sub><i>n</i> &minus; 
                1</sub> <i>x</i> <sup> <i>n</i> - 1</sup>
                + . . .  + <i>a</i><sub>1</sub><i>x</i>
                + <i>a</i><sub>0</sub>, where <i>a</i><sub>0</sub>,
                <i>a</i><sub>1</sub>, . . . , 
                <i>a</i><sub><i>n</i></sub> are real numbers
                with <i>a</i><sub><i>n</i></sub> <i>&ne;</i> 0.
                <br>
                Then <i>f</i>(<i>x</i>) is of 
                order <i>x</i><sup><i>n</i></sup>.
            </p>

        </details>

        <details>
            <summary class="sum2">
                More on the Growth of Functions
            </summary>
            <p>
                <a
                href="https://gcallah.github.io/algorithms/GrowthOfFunctions.html">
                Algorithms class lecture
                </a>
                on the growth of functions.
            </p>

        </details>
    <details>
        <summary class="sum2">
            Test Yourself!
        </summary>
        <ol class="nested">
            <li>
                The Big â€“ O for n! will be:
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q1" value="a">
                n<sup>2</sup>
                </li>
                <li>
                <input type="radio" name="q1" value="b">
                n<sup>n</sup>
                </li>
                <li>
                <input type="radio" name="q1" value="c">
                n<sup>3</sup>
                </li>
                <li>
                <input type="radio" name="q1" value="d">
                n
                </li>
            </ol>
            <li>
                Which of the following functions is O(x)?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q2" value="a">
                f(x) = x<sup>2</sup> + 10x + 2
                </li>
                <li>
                <input type="radio" name="q2" value="b">
                f(x) = 10
                </li>
                <li>
                <input type="radio" name="q2" value="c">
                f(x) = x<sup>x</sup>
                </li>
            </ol>
            <li>
                x<sup>2</sup>   + 4x + 17 is O(x<sup>3</sup>) and x<sup>3</sup> is not O(x<sup>2</sup> + 4x + 17)
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q3" value="a">
                False
                </li>
                <li>
                <input type="radio" name="q3" value="b">
                True
                </li>
            </ol>
            <li>
                What is the Big-O estimate for f(x) = (x + 1) log(x<sup>2</sup> + 1) + 3x<sup>2</sup>?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q4" value="a">
                n<sup>2</sup>
                </li>
                <li>
                <input type="radio" name="q4" value="b">
                n<sup>3</sup>
                </li>
                <li>
                <input type="radio" name="q4" value="c">
                n<sup>n</sup>
                </li>
                <li>
                <input type="radio" name="q4" value="d">
                n<sup>n</sup>
                </li>
            </ol>
            <li>
                What is the witness for f (n) = 3n log(n!) + (n<sup>2</sup>   + 3)log n?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q5" value="a">
                n>2
                </li>
                <li>
                <input type="radio" name="q5" value="b">
                n>log 2
                </li>
                <li>
                <input type="radio" name="q5" value="c">
                n >3
                </li>
                <li>
                <input type="radio" name="q5" value="d">
                n>=2
                </li>
            </ol>
            <li>
                n < 2<sup>n</sup>  whenever n is a positive integer.
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q6" value="a">
                False
                </li>
                <li>
                <input type="radio" name="q6" value="b">
                True
                </li>
            </ol>
        </ol>
        <details>
            <summary class="sum3">
                Answers
            </summary>
            <p>
                1. b; 2. b; 3. a; 4. a; 5. a; 6. b; 
            </p>
        </details>
    </details>
    </details>
    <details>
        <summary class="sum1">
           Complexity of Algorithms 
        </summary>
        <details>
            <summary class="sum2">
                Time Complexity
            </summary>
            <p>
                An analysis of the time required 
                to solve a problem of a particular 
                size involves the time complexity 
                of the algorithm.The time complexity of 
                an algorithm can be expressed 
                in terms of the number of operations 
                used by the algorithm when 
                the input has a particular size.
                <br>
                In most of the cases we consider 
                the worst-case time complexity of an 
                algorithm. This provides an upper
                bound on the number of operations an 
                algorithm uses to solve a problem
                with input of a particular size.
                <br>
                <br>
                <b>Complexity Analysis of Some Algorithms</b>
                <br>
                <b>Example:</b>
                Describe the time 
                complexity of an Algorithm for finding 
                the maximum element in a finite set of integers.
                An analysis of the time required to
                solve a problem of a particular 
                size involves the time 
                complexity of the algorithm.
                The time complexity of 
                an algorithm can be expressed in 
                terms of the number of operations 
                used by the algorithm when the 
                input has a particular size.
                <br>
                In most of the cases we consider the
                worst-case time complexity of an 
                algorithm. This provides an upper bound
                on the number of operations an 
                algorithm uses to solve a problem 
                with input of a particular size.
                <br>
                <br>
                <b>Example:</b>
                Describe the 
                time complexity of an Algorithm
                for finding the maximum element 
                in a finite set of integers.
            </p>

            <ul class="nested">
                <li>
                    Count the number of comparisons
                </li>
                <li>
                    There are  <i>n</i> comparisons  while 
                    entering the for loop, one extra when i
                    becomes equal to <i>n</i>
                </li>
                <li>
                    There are <i>n</i> - 1 comparison in 
                    the if loop to check the maximum element
                </li>
                <li>
                    The total comparison will be 
                    <i>n</i> + (<i>n</i> &minus; 1)<br>
                    2(<i>n</i> &minus; 1) &minus; 1 = 2<i>n</i> &minus; 1 comparisons are made
                    There are <i>n</i> comparisons checking the
                    termination condition of the for loop.
                </li>
                <li>
                    There are <i>n</i> &minus; 1 comparison in the if
                    statement to check the maximum element.
                    </li>
                <li>
                    The total comparisons will be
                    <i>n</i> + (<i>n</i> &minus; 1)
                    = 2<i>n</i> &minus; 1.
                </li>
                <li>
                    Hence, the complexity 
                    will be <i>&Theta;</i>(<i>n</i>)
                </li>
            </ul>       

        </details>

        <details>
            <summary class="sum2">
                Complexity of Matrix Multiplication
            </summary>
            <p>
                The definition of the product 
                of two matrices can be expressed as an
                algorithm for computing the 
                product of two matrices. Suppose that 
                <b>C</b> = [<i>c<sub>ij</sub></i>] is the
                <i>m</i> &#x2715; <i>n</i> matrix that is the 
                product of the <i>m &#x2715; k</i> 
                matrix <b>A</b> = [<i>a<sub>ij</sub></i>] 
                and the <i>k</i> &#x2715; <i>n</i> matrix 
                <b>B</b> = [<i>b<sub>ij</sub></i> ].
                The definition of the product of two matrices can
                be expressed as an
                algorithm for computing the product of
                two matrices. Suppose that 
                <b>C</b> = [<i>c<sub>ij</sub></i>]
                is the <i>m &#x2715; n</i> matrix that is the 
                product of the <i>m &#x2715; k</i>
                matrix <b>A</b> = [<i>a<sub>ij</sub></i>] 
                and the <i>k</i> &#x2715; <i>n</i>
                matrix <b>B</b> = [<i>b<sub>ij</sub></i> ].
                <br>
                <b>Pseudocode Matrix Multiplication</b>
                <br>
            </p>

            <figure>
                <img src="graphics/MatrixMultiplication.svg.png">
            </figure>

            <p>
                <b>Complexity Calculation</b>
                How many additions of integers and 
                multiplications of integers are used 
                by the matrix multiplication algorithm 
                to multiply two <i>n</i> * <i>n </i>matrices.
            </p>

            <ul class="nested">
                <li>
                    There are a total of <i>n</i><sup>2</sup>
                    elements in the product matrix.
                </li>

                <li>
                    Each element requires <i>n</i> multiplications 
                    and <i>n</i> &minus; 1 additions.
                    How many additions of integers and multiplications
                    of integers are used 
                    by the matrix multiplication algorithm to multiply
                    two <i>n</i> * <i>n</i> matrices.
                </li>

                <li>
                    Hence, the complexity of matrix 
                    multiplication is <i>O</i>(<i>n</i><sup>3</sup>).  
                    Hence, the complexity of matrix
                    multiplication is <i>O</i>(<i>n</i><sup>3</sup>).  
                </li>
            </ul>

        </details>

        <details>
            <summary class="sum2">
                Algorithmic Paradigms
            </summary>

            <p>
                Algorithm Paradigms is a general 
                approach based on a particular concept 
                that can be used to construct algorithms 
                for solving a variety of problems.
                Greedy Algorithm, Divide-and-Conquer Algorithm, 
                Brute Force Algorithm, and Probabilistic 
                Algorithm are algorithm paradigms.
                <br>
                <br>
                <b>Example:</b> 
                Brute Force Algorithms
                <br>
                A brute-force algorithm is solved in the most
                straightforward manner,
                without taking advantage of any ideas
                that can make the algorithm more efficient.
                Construct a brute-force algorithm for finding
                the closest pair of 
                points in a set of <i>n</i> points in the
                plane and provide a worst-case 
                estimate of the number of arithmetic operations.
                <br>
                <br>
                <b>Pseudocode for Brute-Force Closest Point Algorithm</b>
                <br>
            </p>

            <figure>
                <img src="graphics/ClosestPairAlgorithm.svg.png">
            </figure>

            <p>
                <b>Complexity of the Algorithm</b>
                <br>
                The algorithm loops through 
                <i>n</i>(<i>n</i> - 1)/2 pairs of 
                points, computes the value    
                (<i>x</i><sub><i>j</i></sub> - 
                <i>x<sub>i</sub></i>)<sup>2</sup>+ 
                (<i>y<sub>j</sub></i> - 
                <i>y<sub>i</sub>)</i><sup>2</sup>and 
                compares it with the minimum, etc.
                So, the algorithm uses
                <i> &Theta;(n</i><sup>2</sup>) 
                The algorithm loops through <i>n</i>(<i>n</i> &minus; 1)/2
                pairs of points, computes the value    
                (<i>x<sub>j</sub></i> &minus;
                <i>x</i><sub><i>i</i></sub>)<sup>2</sup> + 
                (<i>y</i><sub><i>j</i></sub> &minus;
                <i>y</i><sub><i>i</i></sub>)<sup>2</sup> and 
                compares it with the minimum, etc. So, the algorithm uses
                <i> &Theta;</i>(<i>n</i><sup>2</sup>)
                arithmetic and comparison operations.
            </p>
        </details>

        <details>
            <summary class="sum2">
                Understanding the Complexity of Algorithms
            </summary>
            <table>
                <tr>
                    <th class="table-head" colspan="2">
                        Commonly Used Terminology 
                        for the Complexity of Algorithms.
                    </th>
                </tr>
                <tr>
                    <th>
                        Complexity
                    </th>
                    <th>
                        Terminology
                    </th>
                </tr>
                <tr>
                    <td>
                        &Theta;(1)
                    </td>
                    <td>
                        Constant Complexity
                    </td>
                </tr>
                <tr>
                    <td>
                        &Theta;(log <i>n</i>)
                    </td>
                    <td>
                        Logarithmic Complexity
                    </td>
                    </tr>
                    <tr>
                    <td>
                        &Theta;(<i>n</i>)
                    </td>
                    <td>
                        Linear Complexity
                    </td>
                </tr>
                <tr>
                    <td>
                        &Theta;(<i>n</i> log <i>n</i>)
                    </td>
                    <td>
                        Linearithmic complexity
                    </td>
                </tr>
                <tr>
                    <td>
                        &Theta;(<i>n<sup>b</sup></i>)
                    </td>
                    <td>
                        Polynomial complexity
                    </td>
                </tr>
                <tr>
                    <td>
                        &Theta;(<i>b<sup>n</sup></i>) where <i>b</i> &gt;1
                    </td>
                    <td>
                        Exponential Complexity
                    </td>
                </tr>
                <tr>
                    <td>
                        &Theta;(<i>n!</i>)
                    </td>
                    <td>
                        Factorial Complexity
                    </td>
                </tr>
            </table>

            <p>
                <b>Tractable problem: </b>a problem 
                for which there is a worst-case
                polynomial-time algorithm that solves it
                <br>
                <b>Intractable problem: </b>a 
                problem for which no worst-case
                polynomial-time algorithm exists for solving it
                <br>
                <b>Solvable problem: </b>a problem 
                that can be solved by an algorithm
                <br>
                <b>Unsolvable problem: </b>a problem 
                that cannot be solved by an
                algorithm
            </p>

        </details>
    <details>
        <summary class="sum2">
            Test Yourself!
        </summary>
        <ol class="nested">
            <li>
                Brute for algorithms have
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q1" value="a">
                High space complexity
                </li>
                <li>
                <input type="radio" name="q1" value="b">
                High time complexity
                </li>
                <li>
                <input type="radio" name="q1" value="c">
                Both high time and space complexity
                </li>
                <li>
                <input type="radio" name="q1" value="d">
                Low time complexity
                </li>
            </ol>
            <li>
                The brute force algorithm for matrix multiplication has
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q2" value="a">
                Polyarithmatic complexity
                </li>
                <li>
                <input type="radio" name="q2" value="b">
                Polynomial time complexity
                </li>
                <li>
                <input type="radio" name="q2" value="c">
                Linear time complexity
                </li>
                <li>
                <input type="radio" name="q2" value="d">
                Factorial complexity
                </li>
            </ol>
            <li>
                What is the worst case comparisons for Bubble sort?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q3" value="a">
                (n)(n)/2
                </li>
                <li>
                <input type="radio" name="q3" value="b">
                n(n+1)/2 -1
                </li>
                <li>
                <input type="radio" name="q3" value="c">
                (n-1)(n-1)/2
                </li>
                <li>
                <input type="radio" name="q3" value="d">
                (n-1)n/2
                </li>
            </ol>
            <li>
                The order in which n>2 matrices are multiplied also determines the cruntime of the algorithm?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q4" value="a">
                False
                </li>
                <li>
                <input type="radio" name="q4" value="b">
                True
                </li>
            </ol>
            <li>
                In which order should the matrices A1, A2, and A3â€”where A1 is 30 Ã— 20, A2 is 20 Ã— 40, and A3 is 40 Ã— 10, all with integer entriesâ€”be multiplied to use the least number of multiplications of integers?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q5" value="a">
                A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>)
                </li>
                <li>
                <input type="radio" name="q5" value="b">
                (A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>
                </li>
                <li>
                <input type="radio" name="q5" value="c">
                (A<sub>1</sub> A<sub>3</sub>) A<sub>2</sub>
                </li>
            </ol>
            <li>
                What is the least possible multiplication for matrices A1, A2, and A3â€”where A1 is 30 Ã— 20, A2 is 20 Ã— 40, and A3 is 40 Ã— 10, all with integer entries?
            </li>
            <ol type="a" class="nested">
                <li>
                <input type="radio" name="q6" value="a">
                14000
                </li>
                <li>
                <input type="radio" name="q6" value="b">
                10000
                </li>
                <li>
                <input type="radio" name="q6" value="c">
                20000
                </li>
                <li>
                <input type="radio" name="q6" value="d">
                36000
                </li>
            </ol>
        </ol>
        <details>
            <summary class="sum3">
                Answers
            </summary>
            <p>
                1. b; 2. b; 3. d; 4. b; 5. a; 6. a; 
            </p>
        </details>
    </details>
     </details>
 
</body>
</html>


