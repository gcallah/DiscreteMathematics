<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Induction and Recursion
        </title>
    </head>

    <body>

<!--include menu.txt -->

        <h1 class="chap-title">
            Induction and Recursion
        </h1>
            <div style="text-align:center">
                <figure class="lead-figure">
                    <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Sierpinski_triangle.svg/250px-Sierpinski_triangle.svg.png">
                </figure>
            </div>
            

            <details>
                <summary class="sum1">
                Mathematical Induction 
                </summary>
                 <details>
                   <summary class="sum2">
                      Overview
                  </summary>
                <p>
                    Mathematical induction can be used to prove 
                    statements that assert that <i>P(n)</i> is
                    true for all positive integers <i>n</i>,
                    where <i>P(n)</i> is a propositional function
                </p>
                <p class="def"> 
                    <b>PRINCIPLE OF MATHEMATICAL INDUCTION</b>
                </p>
                <p>
                    To prove that <i>P(n)</i> is true for all positive 
                    integers <i>n</i>, where <i>P(n)</i> is 
                    a propositional function, we complete two steps :
                </p>
                <p class="def"> 
                    BASIC STEP: 
                </p>
                <p>
                    We verify that <i>P</i>(1) is true.
                </p>
                <p class="def"> 
                    INDUCTIVE STEP: 
                </p>
                <p>
                     We show that the conditional statement 
                     <i>P(k)</i> &rarr; <i>P(k + 1)</i> is true for
                     all positive integers <i>k</i>.
                 </p>
                 <p>
                     Expressed as a rule of inference, 
                     this proof technique can be stated as
                     <br>
                     <i>(P(1)</i> &and; &forall;<i>k(P(k)</i> &rarr; 
                     <i>P(k</i> + 1))) &rarr; &forall;<i>nP(n)</i>,
                     <br>
                     when the domain is the set of positive integers.
                 </p>
                 </details>

                 <details>
                   <summary class="sum2">
                      Why Mathematical Induction is Valid
                  </summary>
                  <p>
                      The reason comes from the
                      <a href="https://en.wikipedia.org/wiki/Well-order">
                          well-ordering property</a>.
                        <br>
                        <b>To show:</b> Mathematical Induction is valid.
                        <br>
                        <b>Proved Facts: </b><i>P(1)</i> is true and 
                        <i>P(k)</i> implies P(<i>k</i> + 1) is true
                        for all positive integers.
                        <br>
                        <b>Assumption:</b> There is at least one positive 
                        integer for which <i>P(n)</i> is false.
                        <br>
                        <b>Proof:</b>
                        <br>
                        Then the set <i>S</i> of positive integers for which
                        <i>P(n)</i> is false is nonempty. Thus, by the
                        well-ordering property, <i>S</i> has a least element,
                        which will be denoted by <i>m</i>.
                        <br>
                        <i>m</i>
                        cannot be 1, because <i>P(1)</i> is true
                        <br>
                        Because <i>m</i> is positive and greater than 1,
                        <i>m</i> &minus; 1 is a positive integer.
                        <br>
                        Furthermore, because <i>m</i> &minus; 1 is
                        less than <i>m</i>, it is not in <i>S</i>,
                        so <i>P(m</i> &minus; 1) must be true.
                        <br>
                        Because the conditional statement <i>P(m</i> &minus; 1)
                        &rarr; <i>P(m</i>)  is also true, it must be the case
                        that <i>P(m</i>) is true. This contradicts the
                        choice of <i>m</i>).
                        <br>
                        Hence, <i>P(n)</i> must be true
                        for every positive integer <i>n</i>.    
                    </p>
                </details>

                <details>
                    <summary class="sum2">
                        The Good and the Bad of Mathematical Induction
                    </summary>
                    <p>
                        <b>Good: </b>it can be used to prove
                        a conjecture once it is has been made (and is true).
                        <br>
                        <b>Bad: </b>
                        It cannot be
                        be used to find new theorems. 
                        Mathematicians sometimes find
                        proofs by mathematical induction 
                        unsatisfying because they
                        do not provide insights as to why 
                        theorems are true. Many
                        theorems can be proved in many ways, 
                        including by mathematical
                        induction. Proofs of these theorems 
                        by methods other than
                        mathematical induction are often preferred 
                        because of the insights
                        they bring.
                        </p>
                </details>

                <details>
                    <summary class="sum2">
                         Examples of Proofs by Mathematical Induction
                     </summary>
                     <details>
                         <summary class="sum3">
                            Proving Summation Formulae
                        </summary>
                        <p>
                            Show that if n is a positive integer, then
                            1 + 2 + . . . + <i>n</i> =
                            <span class="frac">
                              <sup>
                               <i>n(n+1)</i>
                            </sup>
                            <span>
                                &frasl;
                            </span>
                            <sub>
                                2
                            </sub>
                            </span>
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            P(1) is true, because 1 =
                            <span class="frac">
                                <sup>
                                    1(1+1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                        </p>
                        <p class="def">
                            INDUCTIVE STEP:
                        </p>
                        <p>
                            P(k) holds for an arbitrary
                            positive integer <i>k</i>.
                            we assume that 1 + 2 + . . . + <i>k</i> =
                            <span class="frac">
                                <sup>
                                    <i>k</i>(<i>k</i>+1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
                            Under this assumption,
                            it must be shown that P(<i>k</i> + 1) is true,
                            namely, that
                            <br>
                            1 + 2 + . . . + <i>k</i> + (<i>k</i> + 1) =
                            <span class="frac">
                                <sup>
                                    (<i>k</i> + 1)[(<i>k</i> + 1) + 1]
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <span class="frac">
                                <sup>
                                    (<i>k</i> + 1)(<i>k</i> + 2)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
                            is also true. When we add k + 1 to both sides of 
                            the equation in P(<i>k</i>), we obtain
                            <br>
                            1 + 2+. . .+ <i>k</i> + (<i>k</i> + 1) = 
                            <span class="frac">
                                <sup>
                                    <i>k</i>(<i>k</i>+1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            +
                            (<i>k</i> + 1)
                            <br>
                            =
                            <span class="frac">
                                <sup>
                                    <i>k</i>(<i>k</i> + 1) + 2(<i>k</i> + 1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
                                =
                            <span class="frac">
                                <sup>
                                    (<i>k</i> + 1)(<i>k</i> + 2)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
                            This last equation shows that P(<i>k</i> + 1)
                            is true under the assumption that P(k) is true.
                        </p>
                    </details>

                    <details>
                        <summary class="sum3">
                            Proving Inequalities
                        </summary>
                        <p>
                            Use mathematical induction to prove the inequality
                            <br>
                            <i>n</i> &lt; 2<sup><i>n</i></sup>
                            <br>
                            for all positive integers n.
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            <i>P</i>(1) is true, because 1 &lt; 
                            2<sup>1</sup> = 2.
                            This completes the basis step.
                        </p>
                        <p class="def">
                            INDUCTIVE STEP:
                        </p>
                        <p>
                            We first assume the inductive hypothesis
                            that <i>P(k)</i> is true for an arbitrary
                            positive integer <i>k</i>. That is,
                            the inductive hypothesis <i>P(k)</i> is
                            the statement that <i>k</i> &lt; 
                            2<sup><i>k</i></sup>.
                            <br>
                            We need to show that if <i>P(k)</i> is true,
                            then <i>P(k + 1)</i>, which is the statement
                            that <i>k</i> + 1 &lt;
                            2<sup><i>k</i>+1</sup>, is true.
                            That is, we need to show that if
                            <i>k</i> &lt; 2<sup><i>k</i></sup>,
                            then <i>k</i> + 1 &lt; 
                            2<sup><i>k</i>+1</sup>.
                            <br>

                            <i>k</i> + 1 &lt; 2<sup><i>k</i> +
                            1</sup> &le; 2<sup><i>k</i></sup>
                            + 2<sup><i>k</i></sup> = 2 .
                            2<sup><i>k</i></sup>
                            = 2<sup><i>k</i></sup> + 1.
                            <br>

                            This shows that <i>P</i>(<i>k</i> + 1)
                            is true, namely,
                            that <i>k</i> + 1 &lt;
                            2<sup><i>k</i>+1</sup>,
                            based on the assumption that <i>P</i>(<i>k</i>)
                            is true.
                            </p>
                        </details>

                        <details>
                          <summary class="sum3">
                             Proving Divisibility Results
                         </summary>
                         <p>
                           Use mathematical induction to prove that
                           <i>n<sup>3</sup></i> &minus; <i>n</i> is
                           divisible by 3 whenever <i>n</i> is a
                           positive integer.
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            The statement <i>P</i>(1) is true because
                            1<sup>3</sup> &minus; 1 = 0 is divisible by 3.
                        </p>
                        <p class="def">
                            INDUCTIVE STEP:
                        </p>
                        <p>
                            Assume that <i>P(k)</i> is true; that is, we
                            assume that <i>k</i><sup>3</sup> &minus; <i>k</i> is
                            divisible by 3 for an arbitrary
                            positive integer <i>k</i>
                            <br>
                            (<i>k</i> + 1)<sup>3</sup> &minus; (<i>k</i> + 1)
                            = (<i>k</i><sup>3</sup> + 3<i>k</i><sup>2</sup> +
                            3<i>k</i> + 1) &minus; (<i>k</i> + 1)
                            <br>
                            = (<i>k</i><sup>3</sup> &minus; <i>k</i>) 
                            + 3(<i>k</i><sup>2</sup> + <i>k</i>).
                            Using the inductive hypothesis, 
                            we conclude that the first
                            term <i>k</i><sup>3</sup> &minus; <i>k</i> 
                            is divisible by 3.
                            <br>
                            The second term is divisible by 3 because 
                            it is 3 times an integer.
                            <br>
                            So, (<i>k</i> + 1)<sup>3</sup> &minus; (<i>k</i> + 1)
                            is also divisible by 3.
                        </p>
                    </details>
                <details>
                    <summary class="sum3">
                        Proving Results About Sets
                    </summary>
                        <p>
                            <b>The Number of Subsets of a Finite Set</b>
                            Use mathematical induction to show that if <i>S</i> is a
                            finite set with <i>n</i> elements,
                            where <i>n</i> is a nonnegative integer,
                            then <i>S</i> has 2<sup><i>n</i></sup> subsets.
                            <br>
                            Let <i>P(n)</i> be the proposition that a set
                            with <i>n</i> elements has 2<sup><i>n</i></sup> subsets.
                            <br>
                        </p>
                        <p class="def">
                            BASIS STEP: 
                        </p>
                        <p>
                            <i>P</i>(0) is true,
                            because a set with zero elements,
                            the empty set, has exactly 2<sup><i>0</i></sup> = 1
                            subset, namely, itself.
                        </p>
                        <p class="def">
                            INDUCTIVE STEP:
                        </p>
                        <p>
                            <i>P(k)</i> is true for an arbitrary
                            nonnegative integer <i>k</i>, that is,
                            we assume that every set with
                            <i>k</i> elements has 2<sup><i>k</i></sup> subsets
                            <br>
                            Let <i>T</i> be a set with <i>k</i> + 1 elements.
                            <br>
                            It is possible to write
                            <i>T</i> = <i>S</i> &cup; {a},
                            where a is one of the elements of
                            <i>T</i> and <i>S</i> = <i>T</i> &minus; {a}
                            (and hence |<i>S</i>| = <i>k</i>).
                            <br>
                            The subsets of <i>T</i> can be obtained in
                            the following way.
                            For each subset <i>X</i> of <i>S</i> there are
                            exactly two subsets of <i>T</i> ,
                            namely, <i>X</i> and <i>X</i> &cup; {<i>a</i>}.
                            <br>
                            These constitute all the subsets
                            of <i>T</i> and are all distinct.
                            <br>
                            <i>S</i> has 2<sup><i>k</i></sup> subsets,
                            because it has <i>k</i> elements.
                            We also know that there are two
                            subsets of <i>T</i> for each subset of <i>S</i>.
                            <br>
                            Therefore, there are 2 . 2<sup><i>k</i></sup>
                            = 2<sup><i>k+1</i></sup>
                            subsets of <i>T</i>. This finishes
                            the inductive argument.
                            <br>
                            <i>P(n)</i> is true for all nonnegative
                            integers <i>n</i>. That is, we have proved
                            that a set with <i>n</i> elements
                            has 2<sup><i>n</i></sup>
                            subsets whenever <i>n</i> is a
                            nonnegative integer.
                            <br>
                            <br>
                            <b>NOTE</b>: This is Pascal's Triangle showing up
                            again!
                        </p>
                       </details>

                       <details>
                           <summary class="sum3">
                            Proving Results about Algorithms
                           </summary>
                           <p>
                               Here we will discuss the greedy scheduling
                               algorithm.
                           </p>
                    </details>                        
                </details>
                <details>
                    <summary class="sum2">
                        Mistaken Proofs by Mathematical Induction
                    </summary>
                    <p>
                        Not covered for Fall 2017
                    </p>
                </details>

                <details>
                  <summary class="sum2">
                     Guidelines for Proofs by Mathematical Induction
                 </summary>
                 <p>
                    <b><i>Template for Proofs by Mathematical Induction</i></b>
                 </p>
                 <ol class="nested">
                     <li>
                        Express the statement that is to be
                        proved in the 
                        form "for all <i>n</i> &ge;
                        <i>b</i>, <i>P</i>(<i>n</i>)" 
                        for a fixed integer b.
                     </li>
                     <li>
                        Write out the words "Basis Step." Then show that
                        <i>P</i>(<i>b</i>) is true, taking care
                        that the correct value 
                        of <i>b</i> is used. This completes
                        the first part of the proof.
                     </li>
                     <li>
                        Write out the words "Inductive Step."
                     </li>
                     <li>
                        State, and clearly identify, 
                        the inductive hypothesis, 
                        in the form "assume that <i>P(k)</i> is true
                        for an arbitrary fixed integer <i>k &ge; b</i>."
                     </li>
                    <li>
                        State what needs to be proved under the 
                        assumption that the inductive hypothesis is true.
                        That is, write out what <i>P(k + 1)</i> says.
                    </li>
                    <li>
                        Prove the statement <i>P(k + 1)</i> making use the 
                        assumption <i>P(k)</i>. Be sure that your proof
                        is valid for all integers <i>k</i> with <i>k &ge; b</i>, 
                        taking care that the proof works for small values
                        of <i>k</i>, including <i>k = b</i>.
                    </li>
                    <li>
                        Clearly identify the conclusion of the inductive 
                        step, such as by saying "this completes
                        the inductive step."
                    </li>
                    <li>
                        After completing the basis step and the inductive 
                        step, state the conclusion, namely that
                        by mathematical induction, <i>P(n)</i> is true for 
                        all integers <i>n</i> with <i>n &ge; b</i>.
                    </li>
                </ol>
                </details>
            <!--include quiz5.1.qhtm -->
            </details>

            <details>
                <summary class="sum1">
                    Strong Induction and Well-Ordering
                </summary>
                <h4>
                    Strong Induction
                </h4>
                <p>
                    To prove that <i>P(n)</i> is true
                    for all positive integers <i>n</i>, where <i>P(n)</i>
                    is a propositional function,
                    we complete two steps:
                </p>
                <p class="def">
                    BASIC STEP:
                </p>
                <p>
                    We verify that the proposition <i>P</i>(1) is true.
                </p>
                <p class="def">
                    INDUCTIVE STEP:
                </p>
                <p>
                    We show that the conditional
                    statement [<i>P</i>(1) &or; <i>P</i>(2)
                    &or; . . . &or;
                    <i>P(k</i>)] &rarr; <i>P(k</i> + 1) is true
                    for all positive integers <i>k</i>.
                </p>
                <details>
                    <summary class="sum2">
                        Example
                    </summary>
                    <p>
                    Show that if n is an
                    integer greater than 1,
                    then <i>n</i> can be written
                    as the product of primes.
                    </p>
                    <p class="def">
                        BASIC STEP:
                    </p>
                    <p>
                        <i>P</i>(2) is true, because 2 can
                        be written as the product of one prime, itself.
                    </p>
                    <p class="def">
                        INDUCTIVE STEP:
                    </p>
                    <p>
                        The inductive hypothesis is the
                        assumption that <i>P(j</i>) is true for all
                        integers j with 2 &le; <i>j</i> &le; <i>k</i>, that is,
                        the assumption that <i>j</i> can be written
                        as the product of primes
                        whenever <i>j</i> is a positive integer
                        at least 2 and not exceeding <i>k</i>.
                        <br>
                        There are two cases to consider, 
                        namely, when <i>k</i> + 1 is prime and when 
                        <i>k</i> + 1 is composite.
                        If <i>k</i> + 1 is prime, we immediately see 
                        that <i>P(k</i> + 1) is true. Otherwise, 
                        <i>k</i> + 1 is composite and
                        can be written as the product of two 
                        positive integers <i>a</i> and <i>b</i> with 
                        2 &le; <i>a</i> &le; <i>b</i> <i>k</i> + 1. 
                        <br>
                        Because both <i>a</i> and <i>b</i> are integers at 
                        least 2 and not exceeding <i>k</i>, we can use 
                        the inductive hypothesis to
                        write both <i>a</i> and <i>b</i> as the product of 
                        primes. Thus, if <i>k</i> + 1 is composite, it
                        can be written as the
                        product of primes, namely, 
                        those primes in the factorization 
                        of <i>a</i> and those in the factorization
                        of <i>b</i>.
                        <br>
                        Hence, every nonnegative integer can 
                        be written uniquely as the product of primes 
                        in nondecreasing order.
                    </p>
                </details>
                <details>
                    <summary class="sum2">
                        Using Strong Induction in Computational Geometry
                        <br />
                        Not Covered Spring 2018
                    </summary>
                    <p>
                        Not covered for Spring 2018
                    </p>
                </details>

                <details>
                    <summary class="sum2">
                        Proofs Using the Well-Ordering Property
                        <br />
                        Not Covered Spring 2018
                    </summary>
                    <p>
                        Not covered for Spring 2018
                    </p>
                </details>
            </details>
            <details>
                <summary class="sum1">
                Recursive Definitions and Structural Induction
                </summary>
                <p>
                    <h4>
                        A Recursively Defined Picture.
                    </h4>
                    <figure>
                        <img src = "graphics/RecursiveImage.svg.png">
                    </figure>
                    <br>
                </p>
                <details>
                    <summary class="sum2">
                        Recursively Defined Functions
                    </summary>
                    <p>
                        We use two steps to define a function
                        with the set of nonnegative integers
                        as its domain.
                    </p>
                    <p class="def">
                        BASIC STEP:
                    </p>
                    <p>
                        Specify the value of the
                        function at zero.
                        <br>
                    </p>
                    <p class="def">
                        RECURSIVE STEP:
                    </p>
                    <p>
                        Give a rule for finding its
                        value at an integer from its
                        values at smaller integers.
                        <br>
                        <details>
                            <summary class="sum3">
                                Example
                            </summary>
                            <p>
                                Suppose that f is defined
                                recursively by
                                <br>
                                <i>f</i>(0) = 3,
                                <br>
                                <i>f</i>(n + 1) = 2<i>f</i>(n) + 3.
                                <br>
                                Find <i>f</i>(1), <i>f</i>(2), <i>f</i>(3),
                                and <i>f</i>(4).
                                <br>
                                <i><b>Solution: </b></i>
                                From the recursive definition it
                                follows that
                                <br>
                                <i>f</i>(1) = 2<i>f</i>(0) + 3 =
                                2 * 3 + 3 = 9,
                                <br>
                                <i>f</i>(2) = 2<i>f</i>(1) + 3 =
                                2 * 9 + 3 = 21,
                                <br>
                                <i>f</i>(3) = 2<i>f</i>(2) + 3 =
                                2 * 21 + 3 = 45,
                                <br>
                                <i>f</i>(4) = 2<i>f</i>(3) + 3 =
                                2 * 45 + 3 = 93.       
                            </p>     
                        </details>
                    </p>
                </details>
                    
                <details>
                    <summary class="sum2">
                        Recursively Defined Sets and Structures
                    </summary>
                    <p>
                        In the <b>basis step</b>, an initial collection
                        of elements is specified.
                        <br>
                        In the <b>recursive step</b>,
                        rules for forming new elements in the set from
                        those already known to be in the set are provided.
                        <br>
                        Recursive definitions may also include an <b>exclusion</b>
                        rule, which specifies that a recursively defined set
                        contains nothing other than those elements specified
                        in the basis step or generated by applications of the
                        recursive step.
                    </p>
                    <details>
                        <summary class = "sum3">
                            DEFINITION 1
                        </summary>
                        <p>
                            The set &sum;<sup>*</sup> of strings over the
                            alphabet &sum; is defined recursively by
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            &lambda; &isin; &sum;<sup>*</sup>
                            (where &lambda; is the
                            empty string containing no symbols).
                        </p>
                        <p class ="def">
                            RECURSIVE STEP:
                        </p>
                        <p>
                            If <i>w</i> &isin; &sum;<sup>*</sup> and
                            <i>x</i> &isin; &sum;,
                            then <i>wx</i> &isin; &sum;<sup>*</sup>.
                        </p>
                    </details>
                    <details>
                        <summary class="sum3">
                            DEFINITION 2
                        </summary>
                        <p>
                            Two strings can be combined via
                            the operation of concatenation.
                            Let &sum; be a set of symbols and
                            &sum;<sup>*</sup> the set of
                            strings formed from
                            symbols in &sum;. We can define the
                            concatenation of two strings,
                            denoted by *, recursively as follows.
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            If <i>w</i> &isin; &sum;<sup>*</sup>,
                            then <i>w</i> . &lambda; = <i>w</i>,
                            where &lambda; is the empty string.
                        </p>
                        <p class ="def">
                            RECURSIVE STEP:
                        </p>
                        <p>
                            If <i>w</i><sub>1</sub> &isin; &sum;
                            <sup>*</sup> and <i>w</i><sub>2</sub> &isin;
                            &sum;<sup>*</sup>
                            and x &isin; &sum;, then
                            <i>w</i><sub>1</sub> *
                            (<i>w</i><sub>2</sub>x)
                            = (<i>w</i><sub>1</sub> *
                            <i>w</i><sub>2</sub>)x.
                            <details>
                                <summary class="sum4">
                                    Example
                                </summary>
                                <p>
                                    Give a recursive
                                    definition of l(w), the length
                                    of the string <i>w</i>.
                                    <br>
                                    The length of a string can be
                                    recursively defined by
                                    <br>
                                    l(&lambda;) = 0;
                                    <br>
                                    <i>l(wx</i>) =
                                    <i>l(w</i>) + 1 if <i>w</i>
                                    &isin; &sum;<sup>*</sup> and x &isin; &sum;.
                                </p>
                            </details>
                         </p>   
                    </details>
                    <details >
                        <summary class="sum3">
                            DEFINITION 3
                        </summary>
                        <p>
                            The set of rooted trees,
                            where a rooted tree consists
                            of a set of vertices containing
                            a distinguished vertex called
                            the root, and edges connecting
                            these vertices, can be defined
                            recursively by these steps:
                        </p>
                        <p class="def">
                            BASIC STEP:
                        </p>
                        <p>
                            A single vertex <i>r</i> is a
                            rooted tree.
                        </p>
                        <p class ="def">
                            RECURSIVE STEP:
                        </p>
                        <p>
                            Suppose that <i>T</i><sub>1</sub>,
                            <i>T</i><sub>2</sub>,
                            . . ., <i>T</i><sub>n</sub> are disjoint
                            rooted trees with roots
                            <i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>, . . . ,
                            <i>r</i><sub>n</sub>, respectively.
                            Then the graph formed
                            by starting with a
                            root r, which is not
                            in any of the rooted
                            trees <i>T</i><sub>1</sub>,
                            <i>T</i><sub>2</sub>, . . . , <i>T</i><sub>n</sub>,
                            and adding an edge from
                            <i>r</i> to each of the vertices
                            <i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>,
                            . . . , <i>r</i><sub>n</sub>,
                            is also a rooted tree.
                            <br>
                            <b>Building Up Rooted Trees.</b>
                        </p>
                        <figure>
                            <img src="graphics/RootedTrees.svg.png">
                            <br>
                        </figure>
                    </details>
                    <details>
                        <summary class="sum3">
                            DEFINITION 4
                        </summary>
                        <figure>
                                <img
                                src="https://upload.wikimedia.org/wikipedia/commons/2/26/Waldburg_Ahnentafel.jpg"
                                height="300" width="360">
                                <figcaption>
                                A binary tree
                                </figcaption>
                        </figure>
                        <p>
                            The set of extended binary
                            trees can be defined
                            recursively by these steps:
                        </p>
                        <p class="def">
                            BASIC STEP:
                        </p>
                        <p>
                            The empty set is an extended
                            binary tree.
                        </p>
                        <p class="def">
                            RECURSIVE STEP:
                        </p>
                        <p>
                            If <i>T</i><sub>1</sub>
                            and <i>T</i><sub>2</sub> are disjoint
                            extended binary trees,
                            there is an extended
                            binary tree, denoted by <i>T</i><sub>1</sub>
                            . <i>T</i><sub>2</sub>,
                            consisting of a root <i>r</i>
                            together with edges connecting
                            the root to each of the roots 
                            of the left subtree 
                            <i>T</i><sub>1</sub> and 
                            the right subtree <i>T</i><sub>2</sub> when 
                            these trees are nonempty.
                            <br>
                            <b>Building Up Extended Binary Trees.</b>
                        </p>
                        <figure>
                            <img src="graphics/ExtendedBinary.svg.png">
                        </figure>
                    </details>
    
                    <details>    
                        <summary class="sum3">
                            DEFINITION 5
                        </summary>
                        <p>
                            The set of
                            <a
                                href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">
                            full binary trees 
                            </a>
                            can be defined recursively 
                            by these steps:
                        </p>
                        <p class="def">
                           BASIC STEP: 
                        </p>
                        <p>
                            There is a full binary tree 
                            consisting only of a single vertex <i>r</i>.
                        </p>
                        <p class="def">
                            RECURSIVE STEP:
                        </p>
                        <p>
                           If <i>T</i><sub>1</sub> and
                           <i>T</i><sub>2</sub> are disjoint 
                           full binary trees, there 
                           is a full binary tree,
                           denoted by <i>T</i><sub>1</sub>
                           * <i>T</i><sub>2</sub>, consisting 
                           of a root r together with 
                           edges connecting the root 
                           to each of the roots of 
                           the left subtree <i>T</i><sub>1</sub> and 
                           the right subtree <i>T</i><sub>2</sub>.
                       </p>
                       <figure>
                         <img src="graphics/FullBinary.svg.png">
                     </figure>
                 </details>
             </details>
            <details>
                <summary class="sum2">
                    Structural Induction
                </summary>
                <details>
                    <summary class="sum3">
                        DEFINITION 6
                    </summary>
                    <p>
                        We define the height <i>h(T</i>) 
                        of a full binary tree 
                        <i>T</i> recursively.
                    </p>
                    <p class="def">
                        BASIC STEP: 
                    </p>
                    <p>
                        The height of the full 
                        binary tree <i>T</i> consisting 
                        of only a root <i>r</i> is <i>h(T</i>) = 0.
                    </p>
                    <p class="def">
                        RECURSIVE STEP:
                    </p>
                    <p>
                        If <i>T</i><sub>1</sub> and
                      <i>T</i><sub>2</sub> are full 
                      binary trees, then the 
                      full binary tree <i>v</i> = 
                      <i>T</i><sub>1</sub> * <i>T</i><sub>2</sub>
                      has height <i>h(T</i> ) = 1 + 
                      max(<i>h(T</i><sub>1</sub>), <i>h(T</i><sub>2</sub>)).
                  </p>    
                </details>
            </details>
        </details> 
        <details>
            <summary class="sum1">
                Recursive Algorithms
            </summary>
            <details>
                <summary class="sum2">
                    DEFINITION 1
                </summary>  
                <p>
                    An algorithm is called
                    recursive if it solves 
                    a problem by reducing it 
                    to an instance of the
                    same problem with smaller input.
                </p>
                <details>
                    <summary class="sum3">
                        Example 1
                    </summary>
                    <p>
                        Give a recursive algorithm 
                        for computing <i>n!</i>, where <i>n</i> 
                        is a nonnegative integer.
                    </p>
                    <figure>
                        <img src ="graphics/recursiveEX1.svg.png">
                    </figure>
                </details>
                <details>
                    <summary class="sum3">
                        Example 2
                    </summary>
                    <p>
                        Give a recursive algorithm for 
                        computing <i>a<sup>n</sup></i>, where 
                        a is a nonzero real number 
                        and <i>n</i> is a nonnegative integer.
                    </p>
                    <figure>
                        <img src ="graphics/recursiveEX2.svg.png">
                    </figure>
                </details>
                <details>
                    <summary class="sum3">
                        Example 3
                    </summary>
                    <p>    
                        Give a recursive algorithm 
                        for computing the greatest 
                        common divisor of two nonnegative
                        integers <i>a</i> and <i>b</i> with <i>a</i> &lt; 
                        <i>b</i>.
                    </p>
                    <figure>
                        <img src ="graphics/recursiveEX3.svg.png">
                    </figure>
                </details>
                <details>
                    <summary class="sum3">
                        Example 4
                    </summary>
                    <p>    
                     Devise a recursive algorithm for 
                     computing <i>bn</i> mod <i>m</i>, 
                     where <i>b</i>, 
                     <i>n</i>, and m are integers with
                     <i>m</i> &le; 2, <i>n </i>&ge; 0, 
                     and 1 &le; <i>b</i> &lt; <i>m</i>.
                 </p>
                <figure>
                    <img src ="graphics/recursiveEX4.svg.png">
                </figure>
                </details>
                <details>
                    <summary class="sum3">
                        Example 5
                    </summary>
                    <p>
                        Express the linear search algorithm
                        as a recursive procedure.
                    </p>
                    <figure>
                      <img src ="graphics/recursiveEX5.svg.png">
                    </figure>
                </details>
                <details>
                    <summary class="sum3">
                        Example 6
                    </summary>
                    <p>
                    Construct a recursive version of
                    a binary search algorithm.
                        <figure>
                            <img src ="graphics/recursiveEX6.svg.png">
                        </figure>    
                    </p>
                </details>
            </details>
            <details>
                <summary class="sum2">
                    Recursion and Iteration
                </summary>
                <p>
                    Instead of successively 
                    reducing the computation 
                    to the evaluation of the 
                    function at smaller integers, 
                    we can start with the value 
                    of the function at one or
                    more integers, the base cases, 
                    and successively apply the 
                    recursive definition to
                    find the values of the function
                    at successive larger integers.
                    Such a procedure is 
                    called iterative.
                    <br>
                </p>
                <details>
                    <summary class="sum3">
                        A Recursive Algorithm for Fibonacci Numbers.
                    </summary>
                    <figure>
                        <img src="graphics/recursiveFibonacci.svg.png">
                    </figure>
                </details>
                <details>
                    <summary class="sum3">
                        A Iterative Algorithm for Fibonacci Numbers.
                    </summary>
                    <figure>
                        <img src="graphics/iterativeFibonacci.svg.png">
                    </figure>
                </details>

                <details>
                    <summary class="sum3">
                        The Merge Sort
                    </summary>
                    <p>
                        <b>A Recursive Merge Sort.</b>
                    </p>
                    <figure>
                        <img src="graphics/RecursiveMerge.svg.png"> 
                    </figure>
                    <p>
                        <b>Merging Two lists</b>
                    </p>
                    <figure>
                        <img src="graphics/IterativeMerge.svg.png"> 
                    </figure>
                </details>
            </details>
        </details>

        <details>
            <summary class="sum1">
            Program Correctness
            <br />
            Not Covered Spring 2018
            </summary>
            <details>
                <summary class="sum2">
                    Program Verification
                </summary>
                <p>
                    A program is said to be 
                    correct if it produces the 
                    correct output for every 
                    possible input. A proof
                    that a program is correct 
                    consists of two parts.
                    <br>
                    The first part shows that 
                    the correct answer is
                    obtained if the program 
                    terminates. This part of 
                    the proof establishes the 
                    <b>partial correctness</b>
                     of the program.
                    <br>
                    The second part of the proof shows 
                    that the program always terminates. 
                    <br>
                    To specify what it means 
                    for a program to produce 
                    the correct output, two propositions 
                    are used. 
                    <br>
                    The first is the 
                    initial assertion, which 
                    gives the properties that the 
                    input values must have. 
                    <br> The second is the final 
                    assertion, which gives the properties 
                    that the output of the program should 
                    have, if the program
                    did what was intended. 
                </p>
            </details>
            <details>
                <summary class="sum2">
                    Definition 1
                </summary>
                <p>
                    A program, or program segment, 
                    <i>S</i> is said to be partially 
                    correct with respect to the
                    initial assertion p and the
                    final assertion q if whenever 
                    p is true for the input values
                    of <i>S</i> and <i>S</i> terminates, then q is 
                    true for the output values of <i>S</i>. 
                    The notation p{<i>S</i>}q indicates
                    that the program, or program 
                    segment, <i>S</i> is partially correct
                    with respect to the initial
                    assertion p and the final assertion q.
                </p>   
            </details>
            <h4>
                Conditional Statements
            </h4>
            <p>
                Not covered for Spring 2018
            </p>
            
            <h4>
                Loop Invariants
            </h4>
            <p>
                Not covered for Spring 2018
            </p>
        </details>
    </body>
</html>
