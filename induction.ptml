<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Induction and Recursion
        </title>
    </head>

    <body>

<!--include menu.txt -->

        <h1 class="chap-title">
            Induction and Recursion
        </h1>
            <div style="text-align:center">
                <figure class="lead-figure">
                    <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Sierpinski_triangle.svg/250px-Sierpinski_triangle.svg.png">
                </figure>
            </div>
            

            <details>
                <summary class="sum1">
                Mathematical Induction 
                </summary>
                <p>
                	Mathematical induction can be used to prove 
                	statements that assert that <i>P(n)</i> is
                    true for all positive integers <i>n</i>,
                    where <i>P(n)</i> is a propositional function
                </p>
                <p class="def"> 
                	<b>PRINCIPLE OF MATHEMATICAL INDUCTION</b>
                </p>
                <p>
                	To prove that <i>P(n)</i> is true for all positive 
                	integers <i>n</i>, where <i>P(n)</i> is 
					a propositional function, we complete two steps:
                </p>
                <p class="def"> 
                	BASIC STEP: 
    			</p>
    			<p>
    				We verify that <i>P</i>(1) is true.
    			</p>
    			<p class="def"> 
    				INDUCTIVE STEP: 
    			</p>
    			<p>
    				We show that the conditional statement 
    				<i>P(k)</i> &rarr; <i>P(k + 1)</i> is true for
					all positive integers <i>k</i>.
    			</p>
    			<p>
    				Expressed as a rule of inference, 
    				this proof technique can be stated as
    				<br>
    				<i>(P(1)</i> &and; &forall;<i>k(P(k)</i> &rarr; 
    				<i>P(k</i> + 1))) &rarr; &forall;<i>nP(n)</i>,
    				<br>
    				when the domain is the set of positive integers.
    			</p>

                <details>
                	<summary class="sum2">
                		Why Mathematical Induction is Valid?
                	</summary>
                	<p>
                		The reason comes from the well ordering property.
                		<br>
                		<b>To show :</b> Mathematical Induction is valid.
                		<br>
                		<b>Proved Facts :</b><i>P(1)</i> is true and 
                		<i>P(k)</i> implies <i>(P(k</i>+1) is true
                		for all positive integers.
                		<br>
                		<b>Assumption :</b>There is at least one positive 
                		integer for which <i>P(n)</i> is false.
                		<br>
                		<b>Proof : </b>
                		<br>
                		The set <i>S</i> of positive integers for which
                        <i>P(n)</i> is false is nonempty. Thus, by the
                        well-ordering property, <i>S</i> has a least element,
                        which will be denoted by <i>m</i>.
                        <br>
                        <i>m</i>
                        cannot be 1, because <i>P(1)</i> is true
                        <br>
                        Because <i>m</i> is positive and greater than 1,
                        <i>m</i> - 1 is a positive integer.
                        <br>
                        Furthermore, because <i>m</i> - 1 is
                        less than <i>m</i>, it is not in <i>S</i>,
                        so <i>P(m</i> - 1) must be true.
                        <br>
                        Because the conditional statement <i>P(m</i> - 1)
                        &rarr; <i>P(m</i>)  is also true, it must be the case
                        that <i>P(m</i>) is true. This contradicts the
                        choice of <i>m</i>).
                        <br>
                        Hence, <i>P(n)</i> must be true
                        for every positive integer <i>n</i>.
                	</p>
                </details>

                <details>
                	<summary class="sum2">
                		The Good and the Bad of Mathematical Induction
                	</summary>
                	<p>
                        <b>Good : </b>it can be used to prove
                        a conjecture once it is has been made (and is true).
                        <br>
                        <b>Bad : </b>
                		it is that it cannot a theorem by mathematical induction
                        even if you do not have the slightest idea why it is true?
                        be used to find new theorems. Mathematicians sometimes find
                        proofs by mathematical induction unsatisfying because they
                        do not provide insights as to why theorems are true. Many
                        theorems can be proved in manyways, including by mathematical
                        induction. Proofs of these theorems by methods other than
                        mathematical induction are often preferred because of the insights
                        they bring.
                	</p>
                </details>

                <details>
                	<summary class="sum2">
            			Examples of Proofs by Mathematical Induction
            		</summary>
            		<details>
            			<summary class="sum3">
            				Proving Summation Formulae
            			</summary>
            			<p>
                            Show that if n is a positive integer, then
                            1 + 2 + . . . + <i>n</i> =
                            <span class="frac">
                                <sup>
                                    <i>n(n+1)</i>
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            P(1) is true, because 1 =
                            <span class="frac">
                                <sup>
                                    1(1+1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                        </p>
                        <p class="def">
                            INDUCTIVE STEP:
                        </p>
                        <p>
                            P(k) holds for an arbitrary positive integer <i>k</i>.
                            we assume that 1 + 2 + . . . + <i>k</i> =
                            <span class="frac">
                                <sup>
                                    <i>k</i>(<i>k</i>+1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
                            Under this assumption,
                            it must be shown that P(<i>k</i> + 1) is true,
                            namely, that
                            <br>
                            1 + 2 + . . . + <i>k</i> + (<i>k</i> + 1) =
                            <span class="frac">
                                <sup>
                                    (<i>k</i> + 1)[(<i>k</i> + 1) + 1]
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <span class="frac">
                                <sup>
                                    (<i>k</i> + 1)(<i>k</i> + 2)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
            				is also true. When we add k + 1 to both sides of 
            				the equation in P(<i>k</i>), we obtain
            				<br>
            				1 + 2+. . .+ <i>k</i> + (<i>k</i> + 1) = 
            				<span class="frac">
                                <sup>
                                    <i>k</i>(<i>k</i>+1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            +
                            (<i>k</i> + 1)
                            <br>
                            =
                            <span class="frac">
                                <sup>
                                    <i>k</i>(<i>k</i> + 1) + 2(<i>k</i> + 1)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
            				<br>
                                =
                            <span class="frac">
                                <sup>
                                    (<i>k</i> + 1)(<i>k</i> + 2)
                                </sup>
                                <span>
                                    &frasl;
                                </span>
                                <sub>
                                    2
                                </sub>
                            </span>
                            <br>
                            This last equation shows that P(<i>k</i> + 1)
                            is true under the assumption that P(k) is true.
            			</p>
            		</details>
            	
                	<details>
                		<summary class="sum3">
                			Proving Inequalities
                		</summary>
                        <p>
                            Use mathematical induction to prove the inequality
                            <br>
                            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
                            <i>n</i> < 2<i>n</i>
                            <br>
                            for all positive integers n.
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            <i>P</i>(1) is true, because 1 < 2<sup>1</sup> = 2.
                            This completes the basis step.
                        </p>
                        <p class="def">
                            INDUCTIVE STEP:
                        </p>
                        <p>
                            We first assume the inductive hypothesis
                            that <i>P(k)</i> is true for an arbitrary
                            positive integer <i>k</i>. That is,
                            the inductive hypothesis <i>P(k)</i> is
                            the statement that <i>k</i> < 2<sup><i>k</i></sup>.
                            <br>
                            We need to show that if <i>P(k)</i> is true,
                            then <i>P(k + 1)</i>, which is the statement
                            that <i>k</i> + 1 < 2<sup><i>k</i>+1</sup>, is true.
                            That is, we need to show that if
                            <i>k</i> < 2<sup><i>k</i></sup>,
                            then <i>k</i> + 1 < 2<sup><i>k</i>+1</sup>.
                            <br> <i>k</i> + 1 = 2<sup><i>k</i> +
                            1</sup> &le; 2<sup><i>k</i></sup>
                            + 2<sup><i>k</i></sup> = 2 . 2<sup><i>k</i></sup>
                            = 2<sup><i>k</i></sup> + 1.
                            <br>
                            This shows that <i>P(k</i> + 1) is true, namely,
                            that <i>k</i> + 1 < 2<sup><i>k</i>+1</sup>,
                            based on the assumption that <i>P(k)</i> is true.
                        </p>
                	</details>

                    <details>
                		<summary class="sum3">
                			Proving Divisibility Results
                		</summary>
                        <p>
                            Use mathematical induction to prove that
                            <i>n<sup>3</sup></i> - <i>n</i> is
                            divisible by 3 whenever <i>n</i> is a
                            positive integer.
                        </p>
                        <p class="def">
                            BASIS STEP:
                        </p>
                        <p>
                            The statement <i>P</i>(1) is true because
                            1<sup>3</sup> - 1 = 0 is divisible by 3.
                        </p>
                        <p class="def">
                            INDUCTIVE STEP :
                        </p>
                        <p>
                            Assume that <i>P(k)</i> is true; that is, we
                            assume that <i>k</i><sup>3</sup> - <i>k</i> is
                            divisible by 3 for an arbitrary positive integer <i>k</i>
                            <br>
                            (<i>k</i> + 1)<sup>3</sup> - (<i>k</i> + 1)
                            = (<i>k</i><sup>3</sup> + 3<i>k</i><sup>2</sup> +
                            3<i>k</i> + 1) - (<i>k</i> + 1)
                            <br>
                            = (<i>k</i><sup>3</sup> - <i>k</i>) + 3(<i>k</i><sup>2</sup> + <i>k</i>).
                            Using the inductive hypothesis, we conclude that the first
                            term <i>k</i><sup>3</sup> - <i>k</i> is divisible by 3.
                            <br>
                            The second term is divisible by 3 because it is 3 times an integer.
                            <br>
                            So, (<i>k</i> + 1)<sup>3</sup> - (<i>k</i> + 1)
                            is also divisible by 3.
                        </p>
                	</details>

                    <details>
                		<summary class="sum3">
                			Proving Results about sets
                		</summary>
                        <p>
                            <b>The Number of Subsets of a Finite Set</b>
                            Use mathematical induction to show that if <i>S</i> is a
                            finite set with <i>n</i> elements,
                            where <i>n</i> is a nonnegative integer,
                            then <i>S</i> has 2<sup><i>n</i></sup> subsets.
                            <br>
                            Let <i>P(n)</i> be the proposition that a set
                            with <i>n</i> elements has 2<sup><i>n</i></sup> subsets.
                            <br>
                        </p>
                        <p class="def">
                            BASIS STEP: 
                        </p>
                        <p>
                            <i>P</i>(0) is true,
                            because a set with zero elements,
                            the empty set, has exactly 2<sup><i>0</i></sup> = 1
                            subset, namely, itself.
                        </p>
                        <p class="def">
                            INDUCTIVE STEP :
                        </p>
                        <p>
                            <i>P(k)</i> is true for an arbitrary
                            nonnegative integer <i>k</i>, that is,
                            we assume that every set with
                            <i>k</i> elements has 2<sup><i>k</i></sup> subsets
                            <br>
                            let <i>T</i> be a set with <i>k</i> + 1 elements.
                            <br>
                            It is possible to write <i>T</i> = <i>S</i> &cup; {a},
                            where a is one of the elements of
                            <i>T</i> and <i>S</i> = <i>T</i> - {a}
                            (and hence |<i>S</i>| = <i>k</i>).
                            <br>
                            The subsets of <i>T</i> can be obtained in
                            the following way.
                            For each subset <i>X</i> of <i>S</i> there are
                            exactly two subsets of <i>T</i> ,
                            namely, <i>X</i> and <i>X</i> &cup; {<i>a</i>}.
                            <br>
                            These constitute all the subsets
                            of <i>T</i> and are all distinct.
                            <br>
                            <i>S</i> has 2<sup><i>k</i></sup> subsets,
                            because it has <i>k</i> elements.
                            We also know that there are two
                            subsets of <i>T</i> for each subset of <i>S</i>.
                            <br>
                            Therefore, there are 2 . 2<sup><i>k</i></sup>
                            = 2<sup><i>k+1</i></sup>
                            subsets of <i>T</i>. This finishes
                            the inductive argument.
                            <br>
                            <i>P(n)</i> is true for all nonnegative
                            integers <i>n</i>. That is, we have proved
                            that a set with <i>n</i> elements
                            has 2<sup><i>n</i></sup>
                            subsets whenever <i>n</i> is a
                            nonnegative integer.
                        </p>
                	</details>

                    <details>
                		<summary class="sum3">
                			Proving Results about Algorithms
                		</summary>
                	</details>

                </details>
                <details>
                    <summary class="sum2">
                        Mistaken Proofs by Mathematical Induction
                    </summary>
                    <p>
                    </p>
                </details>

                <details>
            		<summary class="sum2">
            			Guidelines for Proofs by Mathematical Induction
            		</summary>
            		<p>
                        <b><i>Template for Proofs by Mathematical Induction</i></b>
            			<ol>
            				<li>
            					Express the statement that is to be proved in the 
            					form "for all <i>n &ge; b, P(n)</i>" 
            					for a fixed integer b.
            				</li>
            				<li>
            					Write out the words "Basis Step." Then show that
            					<i>P(b</i>) is true, taking care that the correct value 
            					of <i>b</i> is used. This completes the first part of 
            					the proof.
            				</li>
            				<li>
            					Write out the words "Inductive Step."
            				</li>
            				<li>
            					State, and clearly identify, 
            					the inductive hypothesis, 
            					in the form "assume that <i>P(k)</i> is true
								for an arbitrary fixed integer <i>k &ge; b</i>."
            				</li>
            				<li>
            					State what needs to be proved under the 
            					assumption that the inductive hypothesis is true.
								That is, write out what <i>P(k + 1)</i> says.
            				</li>
            				<li>
            					Prove the statement <i>P(k + 1)</i> making use the 
            					assumption <i>P(k)</i>. Be sure that your proof
								is valid for all integers <i>k</i> with <i>k &ge; b</i>, 
								taking care that the proof works for small values
								of <i>k</i>, including <i>k = b</i>.
            				</li>
            				<li>
            					Clearly identify the conclusion of the inductive 
            					step, such as by saying "this completes
								the inductive step."
            				</li>
            				<li>
            					After completing the basis step and the inductive 
            					step, state the conclusion, namely that
								by mathematical induction, <i>P(n)</i> is true for 
								all integers <i>n</i> with <i>n &ge; b</i>.
            				</li>
            			</ol>
            		</p>
                </details>


            </details>

            <details>
                <summary class="sum1">
                Strong Induction and Well-Ordering
                </summary>
                <h4>
                    Strong Induction
                </h4>
                <p>
                    To prove that <i>P(n)</i> is true
                    for all positive integers <i>n</i>, where <i>P(n)</i>
                    is a propositional function,
                    we complete two steps:
                    <br>
                </p>
                <p class="def">
                    BASIC STEP :
                </p>
                <p>
                    We verify that the proposition <i>P</i>(1) is true.
                    <br>
                </p>
                <p class="def">
                    INDUCTIVE STEP :
                </p>
                <p>
                    We show that the conditional
                    statement [<i>P</i>(1) &or; <i>P</i>(2)
                    &or; . . . &or;
                    <i>P(k</i>)] &rarr; <i>P(k</i> + 1) is true
                    for all positive integers <i>k</i>.
                    <br>
                    <b>Example : </b>Show that if n is an
                    integer greater than 1,
                    then <i>n</i> can be written
                    as the product of primes.
                    <br>
                </p>
                <p class="def">
                    BASIC STEP :
                </p>
                <p>
                    <i>P</i>(2) is true, because 2 can
                    be written as the product of one prime, itself.
                <p>
                <p class="def">
                    INDUCTIVE STEP :
                </p>
                <p>
                    The inductive hypothesis is the
                    assumption that <i>P(j</i>) is true for all
                    integers j with 2 &le; <i>j</i> &le; <i>k</i>, that is,
                    the assumption that <i>j</i> can be written
                    as the product of primes
                    whenever <i>j</i> is a positive integer
                    at least 2 and not exceeding <i>k</i>.
                    <br>
                </p>

                <details>
                    <summary class="sum2">
                        Using Strong Induction in Computational Geometry
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Proofs Using the Well-Ordering Property
                    </summary>
                </details>
            </details>
            <details>
                <summary class="sum1">
                Recursive Definitions and Structural Induction
                </summary>
                <p>
                    <h4>
                        A Recursively Defined Picture.
                    </h4>
                    <figure>
                        <img src = "graphics/RecursiveImage.svg.png">
                    </figure>
                    <br>
                </p>
                <h4>
            		Recursively Defined Functions
            	</h4>
            	<p>
                	We use two steps to define a function 
                	with the set of nonnegative integers 
                	as its domain:
                    <br>
                </p>
                <p class="def">
                    BASIC STEP:
                </p>
                <p>
                    Specify the value of the
                    function at zero.
                    <br>
                </p>
                <p class="def">
                    RECURSIVE STEP:
                </p>
                <p>
                    Give a rule for finding its
                    value at an integer from its
                    values at smaller integers.
                    <br>
                    <b>Example:</b>
                    <br>
                    Suppose that f is defined
                    recursively by
                    <br>
                    <i>f</i>(0) = 3,
                    <br>
                    <i>f</i>(n + 1) = 2<i>f</i>(n) + 3.
                    <br>
                    Find <i>f</i>(1), <i>f</i>(2), <i>f</i>(3),
                    and <i>f</i>(4).
                    <br>
                    <i><b>Solution: </b></i>
                    From the recursive definition it
                    follows that
                    <br>
                    <i>f</i>(1) = 2<i>f</i>(0) + 3 =
                    2 . 3 + 3 = 9,
                    <br>
                    <i>f</i>(2) = 2<i>f</i>(1) + 3 =
                    2 . 9 + 3 = 21,
                    <br>
                    <i>f</i>(3) = 2<i>f</i>(2) + 3 =
                    2 . 21 + 3 = 45,
                    <br>
                    <i>f</i>(4) = 2<i>f</i>(3) + 3 =
                    2 . 45 + 3 = 93.
                </p>
                <p class="def">
                    <b>THEOREM 1</b>
                    <br>
                    LAME'S THEOREM
                </p>
                <p>
                    Let <i>a</i> and <i>b</i> be positive integers
                    with <i>a</i> &ge; <i>b</i>. Then the number of
                    divisions used by the Euclidean
                    algorithm to find gcd(<i>a</i>, <i>b</i>)
                    is less than or equal to five times the number
                    of decimal digits in <i>b</i>.
                </p>
                <h4>
                    Recursively Defined Sets and Structures
                </h4>
                <p>
                    In the <b>basis step</b>, an initial collection
                    of elements is specified.
                    <br>
                    In the <b>recursive step</b>,
                    rules for forming new elements in the set from
                    those already known to be in the set are provided.
                    <br>
                    Recursive definitions may also include an <b>exclusion</b>
                    rule, which specifies that a recursively defined set
                    contains nothing other than those elements specified
                    in the basis step or generated by applications of the
                    recursive step.
                </p>
                <p class="def">
                    <b>DEFINITION 1</b>
                </p>
                <p>
                	The set &sum;<sup>*</sup> of strings over the 
                	alphabet &sum; is defined recursively by
				</p>
				<p class="def">
					BASIS STEP: 
				</p>
				<p>			
					&lambda; &isin; &sum;<sup>*</sup>
					(where &lambda; is the 
					empty string containing no symbols).
					<br>
				</p>
				<p class ="def">
					RECURSIVE STEP:
				</p>
				<p> 
					If <i>w</i> &isin; &sum;<sup>*</sup> and
					 <i>x</i> &isin; &sum;, 
					 then <i>wx</i> &isin; &sum;<sup>*</sup>.
					 <br>
                </p>
                <p class="def">
                    <b>DEFINITION 2</b>
                </p>
                <p>
                	Two strings can be combined via 
                	the operation of concatenation.
                	Let &sum; be a set of symbols and 
                	&sum;<sup>*</sup> the set of 
                	strings formed from 
					symbols in &sum;.We can define the 
					concatenation of two strings, 
					denoted by ., recursively as follows.
					<br>
                </p>
                <p class="def">
					BASIS STEP:  
				</p>
				<p>
					If <i>w</i> &isin; &sum;<sup>*</sup>, 
					then <i>w</i> . &lambda; = <i>w</i>, 
					where &lambda; is the empty string.	
				</p>
				<p class ="def">
					RECURSIVE STEP: 
				</p>
				<p>
					If <i>w</i><sub>1</sub> &isin; &sum;
					<sup>*</sup> and <i>w</i><sub>2</sub> &isin; 
					&sum;<sup>*</sup>
					and x &isin; &sum;, then 
					<i>w</i><sub>1</sub> . 
					(<i>w</i><sub>2</sub>x)
					 = (<i>w</i><sub>1</sub> . 
					 <i>w</i><sub>2</sub>)x.
					 <br>
					 <b>Example:</b>Give a recursive 
					 definition of l(w), the length 
					 of the string <i>w</i>.
					 <br>
					 The length of a string can be 
					 recursively defined by
					 <br>
					 l(&lambda;) = 0;
					 <br>
					 <i>l(wx</i>) = <i>l(w</i>) + 1 if <i>w</i> &isin; &sum;
					 <sup>*</sup> and x &isin; &sum;.
					 <br>
				</p>
                <p class="def">
                    <b>DEFINITION 3</b>
                    <br>
                </p>
                <p>
                	The set of rooted trees, 
                	where a rooted tree consists 
                	of a set of vertices containing 
                	a distinguished vertex called 
                	the root, and edges connecting 
                	these vertices, can be defined 
                	recursively by these steps:
                	<br>
                </p>
                <p class="def">
                	BASIC STEP: 
                </p>
                <p>
                	A single vertex <i>r</i> is a 
                	rooted tree.
                </p>
                <p class ="def">
					RECURSIVE STEP: 
				</p>
				<p>
					Suppose that <i>T</i><sub>1</sub>, <i>T</i><sub>2</sub>, 
					. . ., <i>T</i><sub>n</sub> are disjoint 
					rooted trees with roots
					<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>, . . . , 
					<i>r</i><sub>n</sub>, respectively. 
					Then the graph formed 
					by starting with a 
					root r, which is not 
					in any of the rooted 
					trees <i>T</i><sub>1</sub>,
					<i>T</i><sub>2</sub>, . . . , <i>T</i><sub>n</sub>, 
					and adding an edge from 
					<i>r</i> to each of the vertices
					<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>,
					 . . . , <i>r</i><sub>n</sub>, 
					is also a rooted tree.
					<br>
					<b>Building Up Rooted Trees.</b>
				</p>
				<figure>
					<img src="graphics/RootedTrees.svg.png">
					<br>
				</figure>
                <p class="def">
                    <b>DEFINITION 4</b>
                    <br>
                </p>
                <p>
                	The set of extended binary 
                	trees can be defined 
                	recursively by these steps:
                <p class="def">
                	BASIC STEP: 
                </p>
                <p>
                	The empty set is an extended 
                	binary tree.
                </p>
                <p class="def">
                	RECURSIVE STEP:
                </p>
                <p>
                	If <i>T</i><sub>1</sub> 
                	and <i>T</i><sub>2</sub> are disjoint 
                	extended binary trees, 
                	there is an extended
					binary tree, denoted by <i>T</i><sub>1</sub>
					 . <i>T</i><sub>2</sub>, 
					consisting of a root <i>r</i> 
					together with edges connecting
					the root to each of the roots 
					of the left subtree 
					<i>T</i><sub>1</sub> and 
					the right subtree <i>T</i><sub>2</sub> when 
					these trees are nonempty.
					<br>
					<b>Building Up Extended Binary Trees.</b>
					<figure>
						<img src="graphics/ExtendedBinary.svg.png">
					</figure>
                </p>
                	
                <p class="def">
                    <b>DEFINITION 5</b>
                </p>
                <p>
                	The set of full binary trees 
                	can be defined recursively 
                	by these steps:
                	<br>
                </p>
                <p class="def">
                	BASIC STEP: 
                </p>
                <p>
                	There is a full binary tree 
                	consisting only of a single vertex <i>r</i>.
                </p>
                <p class="def">
                	RECURSIVE STEP:
                </p>
                <p>
                	If <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub> are disjoint 
                	full binary trees, there 
                	is a full binary tree,
					denoted by <i>T</i><sub>1</sub> . <i>T</i><sub>2</sub>, consisting 
					of a root r together with 
					edges connecting the root 
					to each of the roots of 
					the left subtree <i>T</i><sub>1</sub> and 
					the right subtree <i>T</i><sub>2</sub>.
					<figure>
						<img src="graphics/FullBinary.svg.png">
					</figure>
					<br>
                </p>
                <h4>
                	Structural Induction
                </h4>
                
                <p class="def">
                    <b>DEFINITION 6</b>
                </p>
                <p>
                	We define the height <i>h(T</i>) 
                	of a full binary tree 
                	<i>T</i> recursively.
                	<br>
                </p>
                <p class="def">
                	BASIC STEP: 
                </p>
                <p>
                	The height of the full 
                	binary tree <i>T</i> consisting 
                	of only a root <i>r</i> is <i>h(T</i>) = 0.
                	<br>
                </p>
                <p class="def">
                	RECURSIVE STEP:
                </p>
                <p>
                	If <i>T</i><sub>1</sub> and
                	 <i>T</i><sub>2</sub> are full 
                	binary trees, then the 
                	full binary tree <i>v</i> = 
                	<i>T</i><sub>1</sub> . <i>T</i><sub>2</sub>
					has height <i>h(T</i> ) = 1 + 
					max(<i>h(T</i><sub>1</sub>), <i>h(T</i><sub>2</sub>)).
                </p>   
            </details>

            <details>
                <summary class="sum1">
                Recursive Algorithms
                </summary>
                <p class="def">
                    <b>DEFINITION 1</b>
                </p>
                <p>
                	An algorithm is called
                	recursive if it solves 
                	a problem by reducing it 
                	to an instance of the
					same problem with smaller input.
					<br>
					<b>Example 1: </b>
					Give a recursive algorithm 
					for computing <i>n!</i>, where <i>n</i> 
					is a nonnegative integer.
					<br>
				</p>
					<figure>
						<img src ="graphics/recursiveEX1.svg.png">
					</figure>
					<br>
				<p>
					<b>Example 2: </b>
					Give a recursive algorithm for 
					computing <i>a<sup>n</sup></i>, where 
					a is a nonzero real number 
					and <i>n</i> is a nonnegative integer.
					<br>
				</p>
					<figure>
						<img src ="graphics/recursiveEX2.svg.png">
					</figure>
				<p>	
					<br>
					<b>Example 3: </b>
					Give a recursive algorithm 
					for computing the greatest 
					common divisor of two nonnegative
					integers a and b with <i>a</i> < <i>b</i>.
					<br>
				</p>
					<figure>
						<img src ="graphics/recursiveEX3.svg.png">
					</figure>
				<p>	
					<br>
					<b>Example 4: </b>
					<br>
					Devise a recursive algorithm for 
					computing <i>bn</i> mod <i>m</i>, 
					where <i>b</i>, 
					<i>n</i>, and m are integers with
					<i>m</i> &le; 2, <i>n </i>&ge; 0, 
					and 1 &le; <i>b</i> < <i>m</i>.
					<br>
				</p>
					<figure>
						<img src ="graphics/recursiveEX4.svg.png">
					</figure>
				<p>
					<b>Example 5: </b>
					Express the linear search algorithm as a recursive procedure.
					<br>
					<figure>
						<img src ="graphics/recursiveEX5.svg.png">
					</figure>
				</p>
				<p>
					<br>
					<b>Example 6: </b>
					Construct a recursive version of a binary search algorithm.
					<br>
					<figure>
						<img src ="graphics/recursiveEX6.svg.png">
					</figure>	
				</p>
				<h4>
					Recursion and Iteration
				</h4>
				<p>
					Instead of successively 
					reducing the computation 
					to the evaluation of the 
					function at smaller integers, 
					we can start with the value 
					of the function at one or
					more integers, the base cases, 
					and successively apply the 
					recursive definition to
					find the values of the function
					at successive larger integers.
					Such a procedure is 
					called iterative.
					<br>
					<b>A Recursive Algorithm for Fibonacci Numbers.</b>
					<figure>
						<img src="graphics/recursiveFibonacci.svg.png">
					</figure>
				</p>
				<p>
					<b>A Iterative Algorithm for Fibonacci Numbers.</b>
				</p>
				<figure>
					<img src="graphics/iterativeFibonacci.svg.png">
				</figure>
				<h4>
					The Merge Sort
				</h4>
				<p>
					<b>A Recursive Merge Sort.</b>
					<figure>
						<img src="graphics/RecursiveMerge.svg.png">	
					</figure>
				</p>
				<p>
					<b>Merging Two lists</b>
					<figure>
						<img src="graphics/IterativeMerge.svg.png">	
					</figure>
				</p>        
            </details>

            <details>
                <summary class="sum1">
                Program Correctness
                </summary>
                <h4>
                	Program Verification
                </h4>
                <p>
                	A program is said to be 
                	correct if it produces the 
                	correct output for every 
                	possible input. A proof
					that a program is correct 
					consists of two parts.
                	<br>
                	The first part shows that 
                	the correct answer is
					obtained if the program 
					terminates. This part of 
					the proof establishes the 
					<b>partial correctness</b>
					of the program.
                	<br>
                	The second part of the proof 
                	shows that the program always terminates.
                	<br>
                	To specify what it means 
                	for a program to produce 
                	the correct output, two propositions
					are used.
					<br>
					The first is the 
					initial assertion, which 
					gives the properties that 
					the input values must
					have.
					<br>
					The second is the final assertion,
					which gives the properties that
					the output of the program
					should have, if the program 
					did what was intended.
					<br>
                </p>
                <p class="def">
                	<b>DEFINITION 1</b>
                </p>
                <p>
                	A program, or program segment, 
                	<i>S</i> is said to be partially 
                	correct with respect to the
					initial assertion p and the 
					final assertion q if whenever 
					p is true for the input values
					of S and S terminates, then q is 
					true for the output values of <i>S</i>. 
					The notation p{<i>S</i>}q indicates
					that the program, or program 
					segment, <i>S</i> is partially correct
					 with respect to the initial
					assertion p and the final assertion q.
                </p>
                <h4>
                	CONDITIONAL STATEMENTS
                </h4>
                <figure>
                </figure>
                <h4>
                	LOOP INVARIANTS
                </h4>
                <figure>
                	
                </figure>
            </details>
            

    </body>
</html>
