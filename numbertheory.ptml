<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Number Theory and Cryptography
        </title>
    </head>

    <body>

<!--include menu.txt -->

        <h1 class="chap-title">
            Number Theory and Cryptography
        </h1>
            <div style="text-align:center">
                <figure class="lead-figure">
                    <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/ModularGroup-FundamentalDomain.svg/220px-ModularGroup-FundamentalDomain.svg.png" width = 33%>
                    <figcaption>
                        Action of the modular group on the upper-half plane
                    </figcaption>
                </figure>
            </div>

            <details>
                <summary class="sum1">
                Divisibility and Modular Arithmetic
                </summary>
                <p>
                <b>Division</b>:
                <br>
                If <i>a</i> and <i>b</i> are integers with <i>a</i> &ne; 0, we say that <i>a</i>
                divides <i>b</i> if there is an integer <i>c</i> such that <i>b</i> = <i>ac</i>,
                or equivalently, if <i>b</i> is an integer. When <i>a</i> divides <i>b</i>
                we say that a is a factor or divisor when <i>a</i> does not divide <i>b</i>.
                </p>
                <br>
                <p>
                <b>Modular Arithmetic</b>:
                If <i>a</i> and <i>b</i> are integers and <i>m</i> is a positive integer,
                then <i>a</i> is congruent to <i>b</i> modulo <i>m</i> if <i>m</i> divides <i>a</i> − <i>b</i>.
                We use the notation <i>a</i> &equiv; <i>b</i> (mod <i>m</i>) to indicate that <i>a</i>
                is congruent to <i>b</i> modulo <i>m</i>. We say that <i>a</i> &equiv; <i>b</i> (mod <i>m</i>)
                is a congruence and that <i>m</i> is its modulus (plural moduli).
                If <i>a</i> and <i>b</i> are not congruent modulo <i>m</i>,
                we write <i>a ̸</i>&equiv; <i>b</i> (mod <i>m</i>).
                </p>
                <p>
                <b>Modular arithmetic </b>is a system of arithmetic
                for integers, where numbers "wrap around"
                upon reaching a certain value—the modulus (plural moduli)
                </p>

                <details>
                    <summary class="sum2">
                    Theorems
                    </summary>
                    <ol class="nested">
                        <li>
                        Let <i>a</i>, <i>b</i>, and <i>c</i> be integers, where <i>a</i> &ne; 0. Then
                        <br>
                        (i) if <i>a</i> | <i>b</i> and <i>a</i> | <i>c</i>, then <i>a</i> | (<i>b</i> + <i>c</i>);
                        <br>
                        (ii) if <i>a</i> | <i>b</i>,then <i>a</i> | <i>bc</i> for all integers <i>c</i>;
                        <br>
                        (iii) if <i>a</i> | <i>b</i> and <i>b</i> | <i>c</i>, then <i>a</i> | <i>c</i>.
                        </li>
                        <li>
                        <b>THE DIVISION ALGORITHM</b> Let <i>a</i> be an integer
                             and <i>d</i> a positive integer. Then there are
                             unique integers <i>q</i> and <i>r</i>, with 0
                             &le; <i>r</i> &lt; <i>d</i>,
                             such that <i>a</i> = <i>dq</i> + <i>r</i>.
                        </li>
                        <li>
                        Let <i>a</i> and <i>b</i> be integers, and let <i>m</i> be a positive integer.
                        Then <i>a</i> &equiv; <i>b</i> (mod <i>m</i>) if and only if <i>a</i> mod <i>m</i> = <i>b</i> mod <i>m</i>.
                        </li>
                        <li>
                        Let <i>m</i> be a positive integer. The integers <i>a</i> and <i>b</i> are
                        congruent modulo <i>m</i> if and only if there is an
                        integer <i>k</i> such that <i>a</i> = <i>b</i> + <i>km</i>
                        </li>
                        <li>
                        Let <i>m</i> be a positive integer. If <i>a</i> &equiv; <i>b</i> (mod <i>m</i>)
                        and <i>c</i> &equiv; <i>d</i> (mod <i>m</i>), then <i>a</i> + <i>c</i> &equiv; <i>b</i> + <i>d</i> (mod <i>m</i>)
                        and <i>ac</i> &equiv; <i>bd</i> (mod <i>m</i>).
                        </li>
                    </ol>
                    <p>
                    <b>Corollary:</b> 1. If <i>a</i>, <i>b</i>, and <i>c</i> are integers,
                    where <i>a</i> &ne; 0, such that <i>a</i> | <i>b</i> and <i>a</i> | <i>c</i>, then
                    <i>a</i> | <i>mb</i> + <i>nc</i> whenever <i>m</i> and <i>n</i> are integers.
                    <br>
                    2. Let <i>m</i> be a positive integer and let <i>a</i> and <i>b</i> be
                    integers. Then (<i>a</i> + <i>b</i>) mod <i>m</i> = ((<i>a</i> mod <i>m</i>) + (<i>b</i> mod <i>m</i>)) mod <i>m</i>
                    and
                    <i>ab</i> mod <i>m</i> = ((<i>a</i> mod <i>m</i>)(<i>b</i> mod <i>m</i>)) mod <i>m</i>.
                    </p>
                </details>
            </details>

            <details>
                <summary class="sum1">
                Integer Representations and Algorithms
                </summary>
                <p>
                The most common representation of a positive integer is a
                string of bits, using the binary numeral system. The order
                of the memory bytes storing the bits varies; see endianness.
                The width or precision of an integral type is the number
                of bits in its representation. An integral type with <i>n</i>
                bits can encode 2<i>n</i> numbers; for example an unsigned type
                typically represents the non-negative values 0 through 2<sup><i>n</i></sup>−1.
                Other encodings of integer values to bit patterns are
                sometimes used, for example Binary-coded decimal or Gray code,
                or as printed character codes such as ASCII.
                </p>
                <details>
                    <summary class="sum2">
                    Theorems
                    </summary>
                    <ol class="nested">
                    <li>
                    Let <i>b</i> be an integer greater than 1. Then if <i>n</i> is a positive
                    integer, it can be expressed uniquely in the form
                    <br>
                    <i>n</i> = a<sub>k</sub>b<sup>k</sup> + a<sub>k-1</sub>b<sup>k-1</sup> +···+ a<sub>1</sub>b + a<sub>0</sub>,
                    <br>
                    where <i>k</i> is a nonnegative integer, a<sub>0</sub>, a<sub>1</sub>, . . . , a<sub>k</sub>
                    are non-negative integers less than <i>b</i>, and a<sub>k</sub> &ne; 0.
                    </li>
                    </ol>
            </details>
            </details>
            <details>
                <summary class="sum1">
                Algorithms for Integer Operations
                </summary>
                <p>
                The algorithms for performing operations with integers using their
                binary expansions are extremely important in computer arithmetic.
                </p>
                <p>
                We will describe algorithms for the addition and the multiplication
                of two integers expressed in binary notation.
                </p>
                <details>
                    <summary class="sum2">
                    Types of Algorithms
                    </summary>
                    <ol class="nested">
                    <li>
                    <i>ADDITION ALGORITHM:</i>
                    Consider the problem of adding two integers in binary notation.
                    A procedure to perform addition can be based on the usual
                    method for adding numbers with
                    pencil and paper. This method proceeds by adding
                    pairs of binary digits together with carries,
                    when they occur, to compute the sum of two integers.
                    <br>
                    <i>Example:</i>Add <i>a</i> = (1110)<sub>2</sub> and <i>b</i> = (1011)<sub>2</sub>
                    <br>
                    <i>Solutions:</i>
                    Following the procedure specified in the algorithm, first note that
                    <br>
                    <i>a</i><sub>0</sub> + <i>b</i><sub>0</sub> = 0 + 1 = 0·2 + 1,
                    <br>
                    so that <i>c</i><sub>0</sub> = 0 and <i>s</i><sub>0</sub> = 1. Then, because
                    <br>
                    <i>a</i><sub>1</sub> + <i>b</i><sub>1</sub> + <i>c</i><sub>0</sub> = 1 + 1 + 0 = 1·2 + 0,
                    <br>
                    it follows that <i>c</i><sub>1</sub> = 1 and <i>s</i><sub>1</sub> = 0. Continuing,
                    <br>
                    <i>a</i><sub>2</sub> + <i>b</i><sub>2</sub> + <i>c</i><sub>1</sub> = 1 + 0 + 1 = 1·2 + 0,
                    <br>
                    so that <i>c</i><sub>2</sub> = 1 and <i>s</i><sub>2</sub> = 0.
                    Finally, because <i>a</i><sub>3</sub> + <i>b</i><sub>3</sub> +
                    <i>c</i><sub>2</sub> = 1 + 1 + 1 = 1·2 + 1,
                    <br>
                    follows that <i>c</i><sub>3</sub> = 1 and <i>s</i><sub>3</sub> = 1.
                    This means that <i>s</i><sub>4</sub> = <i>c</i><sub>3</sub> = 1.
                    Therefore, <i>s</i> = <i>a</i> + <i>b</i> = (11001)<sub>2</sub>.
                    </li>
                    <li>
                    <i>MULTIPLICATION ALGORITHM:</i>
                    Consider the multiplication of two <i>n</i>-bit
                    integers <i>a</i> and <i>b</i>.
                    The conventional algorithm (used when multiplying with pencil and paper)
                    works as follows. Using the distributive law, we see that
                    <br>
                    <i>ab</i> = <i>a</i>(<i>b</i><sub>0</sub>2<sup>0</sup>
                    + <i>b</i><sub>1</sub>2<sup>1</sup> +···+ <i>b</i><sub><i>n</i>−1</sub>2<sup><i>n</i>−1</sup>)
                    <br>:
                    = <i>a</i>(<i>b</i><sub>0</sub>2<sup>0</sup>)
                    + <i>a</i>(<i>b</i><sub>1</sub>2<sup>1</sup>)
                    + · · · + <i>a</i>(<i>b</i><sub><i>n</i>−1</sub>2<sup><i>n</i>−1</sup>)
                    </li>
                    </ol>
                </details>
            </details>

            <details>
                <summary class="sum1">
                Primes and Greatest Common Divisors
                </summary>
                <p>
                A prime is an integer excluding 1, that is divisible by no
                positive integers other than 1 and itself. <br>
                </p>
                <p>
                Prime numbers are quite important as they are used in modern
                cryptographic systems. The length of time required to factor
                large integers into their prime factors is the basis for the
                strength of these systems.<br>
                </p>
                <p>
                <b>Definition 1</b>: An integer <i>p</i> greater than 1 is called prime
                if the only positive factors of <i>p</i> are 1 and <i>p</i>. A
                positive integer that is greater than 1 and is not prime is
                called composite.<br>
                </p>
                <p>
                <b>Definition 2</b>: If <i>n</i> is a composite integer, then
                <i>n</i> has a prime divisor less than or equal to &radic; n
                .<br><br>
                </p>
                <details>
                    <summary class="sum2">
                        <b>The seive of eratosthenes</b> 
                    </summary>
                        <ol class=" nested">
                            <li> The sieve of Eratosthenes is used to find all primes not exceeding a specified positive integer. 
                For instance, the following procedure is used to find the
                primes not exceeding 100.<br>
                            </li>
                            <li>
                Because the only primes less than 10 are 2, 3, 5, and 7, the primes not exceeding 100 are these 
                four primes and those positive integers greater than 1 and not exceeding 100 that are divisible by
                none of 2, 3, 5, or 7<br> <br>
                            </li>
                        </ol>
                </details>
                <p>
                <b> Greatest common divisor (gcd) </b> The largest integer that
                divides both the two integers.<br>
                </p>
                <p>
                <b>Relatively prime</b> Two numbers are said to be realtively
                prime if their gcd is 1 <br>
                </p>
                <p>
                <b>Least Common Multiple (lcm)</b> the smallest integer that is
                divisible by both a and b.<br>
                </p>
                <p>If <i>a</i> and <i>b</i> are positvie integers then,
                <i>a</i><i>b</i> &equals; gcd(<i>a</i>,<i>b</i>) &mul;
                lcm(<i>a</i>.<i>b</i>) <br>
                </p>
                <p> <b> Eucledian Algorithm</b> Computing gcd using prime
                factorization is a time consuming process. Eucledian algorithm
                gives an efficient way to compute gcd.<br> 
                </p>
                <p>
                <b> Steps</b>
                To find gcd(<i>a</i>, <i>b</i>)
                <ol class = "nested">
                    <li>
                        Divide the larger of two numbers (say <i>a</i>) by the
                        smaller number (say <i>b</i>) , let the divisor be
                        (<i>c</i>)
                    </li>
                    <li>
                        Now, the problem changes to finding
                        gcd(<i>b</i>, <i>c</i>) 
                    </li>
                    <li>
                        Continue the above procedure,till one of the integers
                        is 0
                    </li>
                </ol>

                </p>

            </details>

            <details>
                <summary class="sum1">
                Solving Congruences
                </summary>
            </details>

            <details>
                <summary class="sum1">
                Applications of Congruences
                </summary>
            </details>

            <details>
                <summary class="sum1">
                Cryptography
                </summary>
            </details>
    </body>
</html>
