<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Trees
        </title>
    </head>

    <body>

    <div id="header">
        <div id="logo">
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/250px-6n-graf.svg.png"
            height="56" width="84"
            max-height=100%>
        </div>
        <div id="user-tools">
            <a href="index.html">Home</a>
            &nbsp; &nbsp; 
            <a href="about.html">About</a>
        </div>
    </div>


        <h1 class="chap-title">
            Trees
        </h1>
            <div style="text-align:center">
                <figure class="lead-figure">
                    <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Caterpillar_tree.svg/300px-Caterpillar_tree.svg.png">
                </figure>
            </div>

            <details>
                <summary class="sum1">
                Introduction to Trees
                </summary>

                <p class="def">
                    Tree
                </p>

                <p>
                    No circuits, unique simple path.
                </p>

                <p class="def">
                    Forest
                </p>
                <p>
                  Forest is a set of zero or more disjoint trees.
                </p>

                <details>
                    <summary class="sum2">
                        Rooted Trees
                    </summary>

                    <ul class="nested">
                    <li>
                    Root
                    </li>
                    <li>
                    Leaf
                    </li>
                    <li>
                    Subtree
                    </li>
                    <li>
                        <b>Siblings</b>:
                        vertices with the same parent
                    </li>
                    <li>
                    M-ary tree
                    </li>
                    <li>
                    Full m-ary tree
                    </li>
                    </ul>

                </details>

                <details>
                    <summary class="sum2">
                        Trees as Models
                    </summary>

                    <figure>
                        <img src="graphics/OrgChart.png">
                        <figcaption>
                            An org chart
                            <br />
                            (Source:
                            https://en.wikipedia.org/wiki/Organizational_chart)
                        </figcaption>
                    </figure>
                    
                    <ul class="nested">
                        <li>
                            (Some) molecules
                        </li>
                        <li>
                            Org charts
                        </li>
                        <li>
                            Computer file systems
                        </li>

                    </ul>

                </details>

                <details>
                    <summary class="sum2">
                        Properties of Trees
                    </summary>
                    <summary class="sum3">
                       Theorem 2:
                    </summary>
                    <p>
                    A tree with <i>n</i> vertices has <i>n</i> − 1 edges.
                    </p>
                    <summary class="sum3">
                       Theorem 3:
                    </summary>
                    <p>
                    A full <i>m</i>-ary tree with i internal vertices contains <i>n</i> = <i>m</i>*<i>i</i> + <i>1</i> vertices.
                    </p>
                    <summary class="sum3">
                       Theorem 4:
                    </summary>
                    <p>
                    A full <i>m</i>-ary tree with
                    <ol class="nested">
    <li> <i>n</i> vertices has <i>i = (n − 1)/m </i>internal vertices and <i>l = [(m − 1)n + 1]/m</i> leaves,</li>
    <li> <i>i</i> internal vertices has <i>n</i> = <i>m</i>*<i>i</i> + <i>1</i> vertices and <i>l</i> = <i>(m − 1)i + 1</i> leaves,</li>
    <li> <i>l</i> leaves has <i>n = (ml − 1)/(m − 1)</i> vertices and <i>i = (l − 1)/(m − 1) </i>internal vertices.</li>
    </ol>
                    </p>
                    <summary class="sum3">
                       Theorem 5:
                    </summary>
                    <p>
                      There are at most <i>m</i> <sup> <i>h</i> </sup>leaves in an m-ary tree of height <i>h</i>.
                    </p>


                </details>

            </details>

            <details>
                <summary class="sum1">
                Applications of Trees
                </summary>
                <p>
                  Trees provide easier location of items.
                  Depending on a certain property, items are stored in a tree
                  data structure for faster retrieval.
                </p>
                <details>
                    <summary class="sum2">
                        Binary Search Trees
                    </summary>

                    <p>
                        <a
                            href="https://gcallah.github.io/algorithms/BinarySearchTrees.html">
                            Binary Search Trees from DAA
                        </a>
                    </p>

                </details>

                <details>
                    <summary class="sum2">
                        Decision Trees
                        <br />
                        NOT COVERED FALL 2017
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Prefix Codes
                    </summary>

                    <details>
                        <summary class="sum3">
                            Introduction
                        </summary>

                        <p>
                        Prefix codes are coding schemes in which no codeword
                        is a prefix of a different codeword.
                        <br>
                        This makes decoding easier -- no lookahead.
                        (<b>else</b> and <b>else-if</b>)
                        <br />
                        It means that we never hit two letters on the same path
                        down the tree!
                        </p>

                        <table>
                            <tr>
                                <td>
                                </td>
                                <th>
                                    a
                                </th>
                                <th>
                                    b
                                </th>
                                <th>
                                    c
                                </th>
                                <th>
                                    d
                                </th>
                                <th>
                                    e
                                </th>
                                <th>
                                    f
                                </th>
                            </tr>
                            <tr>
                                <th>
                                    Frequency (in 1000s)
                                </th>
                                <td>
                                    45
                                </td>
                                <td>
                                    13
                                </td>
                                <td>
                                    12
                                </td>
                                <td>
                                    16
                                </td>
                                <td>
                                    9
                                </td>
                                <td>
                                    5
                                </td>
                            </tr>
                            <tr>
                                <th>
                                    Codeword
                                </th>
                                <td>
                                    0
                                </td>
                                <td>
                                    101
                                </td>
                                <td>
                                    100
                                </td>
                                <td>
                                    111
                                </td>
                                <td>
                                    1101
                                </td>
                                <td>
                                    1100
                                </td>
                            </tr>
                        </table>
                    </details>

                    <details>
                        <summary class="sum3">
                            Huffman codes
                        </summary>

                        <p>
                        <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Huffman_tree_2.svg/220px-Huffman_tree_2.svg.png">
                        <br>
                        <br>
                        Hoffman coding is away of compressing data
                        that consists of characters buy creating
                        short binary representations for the
                        characters that occur most frequently
                        in the data, and using longer representations
                        for characters that occur less frequently.
                        </p>

                        <figure>
                            <iframe width="560" height="315"
                                src="https://www.youtube.com/embed/dM6us854Jk0"
                                frameborder="0" allowfullscreen></iframe>
                            <figcaption>
                                Huffman coding
                            </figcaption>
                        </figure>
                    </details>


                    <details>
                        <summary class="sum3">
                        Constructing a Huffman code
                        </summary>

                        <p>
                            We build a binary tree from the bottom-up,
                            starting with the two least-frequent characters,
                            and building up from there. This ensures the
                            least-frequent characters have the longest codes.
                            <br>
                            <br>
                            Consider the phrase "Mississippi River".
                            This is 136 bits in 8-bit ASCII encoding.
                            <br>
                            <br>
                            Here is the Huffman coding for it:
                            <br>
                            <img src="graphics/Huffman.png">
                            <br>
                            <br>
                            I = 00
                            <br>
                            S = 01
                            <br>
                            P = 100
                            <br>
                            R - 101
                            <br>
                            M = 1100
                            <br>
                            V = 1101
                            <br>
                            E = 1110
                            <br>
                            _ = 1111
                            <br>
                            <br>
                            The final string:
                            <br>
                            110000010100010100100100001111101001101101
                            <br>
                            <br>
                            Try parsing it, and convince yourself that
                            there is only one possible interpretation
                            of it. That is what the prefix coding buys us.
                        </p>
                    </details>
                </details>

                <details>
                    <summary class="sum2">
                        Game Trees
                    </summary>
                    <p>
                      Trees can be used to analyze certain type of games like
                      tic-tac-toe where there is no element of chance and
                      previous move is known to each player.
                    </p>
                    <p>
                      The vertices of trees represent position that a game can
                      be in as the game progresses, the edge represent legal
                      moves between these positions
                    </p>
                    <p>
                      Game trees can be simplified by representing all
                      symmetric positions of game by the same vertex.
                    </p>
                    <p>
                    However, same position of the game may be represent by
                    different vertices if different sequences of moves lead to
                    this position.
                    </p>
                </details>

            </details>

            <details>
                <summary class="sum1">
                Tree Traversal
                </summary>

                <details>
                    <summary class="sum2">
                        Universal Address Systems
                        <br />
                        NOT COVERED FALL 2017
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Traversal Algorithms
                    </summary>

                    <details>
                        <summary class="sum3">
                            Preorder Traversal
                        </summary>

                        <figure>
                            <img
                            src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png">
                            <figcaption>
                                Preorder traversal: F, B, A, D, C, E, G, I, H.
                            </figcaption>
                        </figure>

                        <p>
                        Preorder pseudocode:
                        </p>
                        <p>
                        <code>
                    <pre>
                    preorder(T):
                        if T == nil:
                            return
                        else:
                            print(T)
                            preorder(T.left)
                            preorder(T.right)
                    </pre>
                        </code>
                        </p>

                    </details>

                    <details>
                        <summary class="sum3">
                            Inorder Traversal
                        </summary>

                        <figure>
                            <img
                                 src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png">
                            <figcaption>
                                Inorder traversal: A, B, C, D, E, F, G, H, I.
                            </figcaption>
                        </figure>
                        <p>
                        Inorder pseudocode:
                        </p>
                        <p>
                        <code>
                    <pre>
                    inorder(T):
                        if T == nil:
                            return
                        else:
                            inorder(T.left)
                            print(T)
                            inorder(T.right)
                    </pre>
                        </code>
                        </p>

                    </details>

                    <details>
                        <summary class="sum3">
                            Postorder Traversal
                        </summary>

                        <figure>
                            <img
                                 src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png">
                            <figcaption>
                                Postorder traversal: A, C, E, D, B, H, I, G, F.
                            </figcaption>
                        </figure>

                        <p>
                        Postorder pseudocode:
                        </p>
                        <p>
                        <code>
                    <pre>
                    postorder(T):
                        if T == nil:
                            return
                        else:
                            postorder(T.left)
                            postorder(T.right)
                            print(T)
                    </pre>
                        </code>
                        </p>

                    </details>

                    <details>
                        <summary class="sum3">
                            Infix, Prefix, and Postfix Notation
                        </summary>

                        <figure>
                            <img src="graphics/ParseTree.png">
                            <figcaption>
                                Parse tree for ((x + y)^2) + ((x - 4) / 3)
                            </figcaption>
                        </figure>

                        <p>
                        <b>Prefix form</b>: + ^ + x y 2 / - x 4 3
                        <br />
                        <b>Postfix form</b>: x y + 2 ^ x 4 - 3 / +
                        <br />
                        </p>

                    </details>

                </details>
            </details>

            <details>
                <summary class="sum1">
                Spanning Trees
                </summary>

                <details>
                    <summary class="sum2">
                        Introduction
                    </summary>

                    <p>
                        The <i>spanning tree</i> of a graph <i>G</i>
                        is a subgraph of <i>G</i> that is a tree
                        and that contains every vertex of G.
                    </p>

                    <p>
                        A graph is connected if and only if it has a spanning
                        tree.
                        <br />
                        We prove this by removing edges from circuits.
                    </p>

                </details>

                <details>
                    <summary class="sum2">
                        Depth-First Search (DFS)
                    </summary>

                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/300px-Depth-first-tree.svg.png">
                        <figcaption>
                            The order in which nodes are visited in a DFS.
                        </figcaption>
                    </figure>
                    <p>
                        This is a way to find a spanning tree in a connected
                        graph (or detect that the graph is unconnected).
                        <br />
                        The edges used to form that tree are called
                        <b>tree edges</b>.
                        <br />
                        The edges not used in forming that tree are called
                        <b>back edges</b> (because they lead <i>back</i>
                        to a node already visited). If there are back edges,
                        they show that circuits exist in the graph. And if
                        there are unvisited vertices when DFS is done,
                        then the graph is not connected.
                        <br />
                        So, DFS can:
                    </p>

                    <ul class="nested">
                        <li>
                            Find spanning trees
                        </li>
                        <li>
                            Detect circuits
                        </li>
                        <li>
                            Detect if a graph is connected
                        </li>
                    </ul>

                </details>

                <details>
                    <summary class="sum2">
                        Breadth-First Search
                    </summary>

                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/Breadth-first-tree.svg/300px-Breadth-first-tree.svg.png">
                        <figcaption>
                            The order in which nodes are visited in a BFS.
                        </figcaption>
                    </figure>
                </details>

                <details>
                    <summary class="sum2">
                        Backtracking Applications
                        <br />
                        NOT COVERED FALL 2017
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Depth-First Search in Directed Graphs
                        <br />
                        NOT COVERED FALL 2017
                    </summary>
                </details>

            </details>

            <details>
                <summary class="sum1">
                Minimum Spanning Trees
                </summary>

                <details>
                    <summary class="sum2">
                        Introduction
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Algorithms for Minimum Spanning Trees
                    </summary>

                    <p>
                        <a
                            href="https://gcallah.github.io/algorithms/MinimumSpanningTrees.html">
                            Minimum Spanning Trees from DAA
                        </a>
                    </p>

                </details>
            </details>

            <h3>
                Credits
            </h3>
            <ul class="nested">
                <li>
                    Images from Wikipedia are linked to the original.
                </li>
            </ul>

    </body>
</html>
