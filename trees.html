<html>
<!-- THIS FILE WAS GENERATED BY A SCRIPT: DO NOT EDIT IT! -->
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Trees
        </title>
    </head>

    <body>

    <div id="header">
        <div id="logo">
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/250px-6n-graf.svg.png"
            height="56" width="84"
            max-height=100%>
        </div>
        <div id="user-tools">
            <a href="index.html">Home</a>
            &nbsp; &nbsp; 
            <a href="about.html">About</a>
        </div>
    </div>


        <h1 class="chap-title">
            Trees
        </h1>
            <div style="text-align:center">
                <figure class="lead-figure">
                    <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Caterpillar_tree.svg/300px-Caterpillar_tree.svg.png" width="24%">
                </figure>
            </div>

            <details>
                <summary class="sum1">
                Introduction to Trees
                </summary>

                <p class="def">
                    Tree
                </p>

                <p>
                    A tree is a connected graph with no circuits and a
                    unique simple path between any of it's vertices.
                </p>

                <figure>
                    <img src="graphics/DirectedCyclicGraphs.svg" width="20%">
                    <figcaption>
                        Not a Tree
                        <br />
                        (Source:
                        https://en.wikipedia.org/wiki/Tree_(data_structure))
                    </figcaption>
                </figure>

                <p class="def">
                    Forest
                </p>
                <p>
                  Forest is a graph containing zero or more disjoint trees.
                </p>

                <details>
                    <summary class="sum2">
                        Rooted Trees
                    </summary>
                    <p class="def">
                       Definition:
                    </p>
                    <p>
                        A rooted tree is an acyclic graph,
                        with one vertex designated as root.
                    </p>
                    <ul class="nested">
                    <li>
                        <b>Root</b>
                        A vertex is defined in a tree as a root.
                        It is the entry point of a tree.
                    </li>
                    <li>
                        <b>Parent</b>
                        A vertex <i>u</i> is said to be a parent of <i>v</i>, if there is a unidirected edge from <i>u</i> to <i>v</i>. A root has no parent
                    </li>
                    <li>
                       <b>Child</b>
                       The vertex <i>v</i> defined above is a child of <i>u</i>
                    </li>
                    <li>
                        <b>Leaf</b>
                        The last vertices of a tree are leaf.
                        leaf has no children
                    </li>
                    <li>
                        <b>Subtree</b>
                        A tree formed by an internal vertex,
                         which is not a root.
                    </li>
                    <figure>
                        <img src="graphics/tree_example.gif" width="33%">
                        <figcaption>
                            Tree Example
                            <br />
                            (Source:
                            http://holowczak.com/programming-concepts-tutorial-programmers/4/)
                        </figcaption>
                    </figure>
                    <li>
                        <b>Siblings</b>:
                        vertices with the same parent
                    </li>
                    <li>
                        <b>Ancestors</b>:
                        vertices which come along the path when
                        traversing to a vertex from the root.
                        It doesnot include the vertex
                    </li>
                    <li>
                        <b>Decendants</b>:
                        Decendants of a vertex are vertices which
                        come along the path when traversing from the vertex
                        to a leaf, excluding the vertex itself.
                    </li>
                    <li>
                       <b>M-ary tree</b>
                       A tree with every internal vertices
                       having no more than m children.
                    </li>
                    <li>
                        <b>Full m-ary tree</b>
                        A tree with every internal vetrx having
                        exactly m children.
                    </li>
                    </ul>

                </details>

                <details>
                    <summary class="sum2">
                        Trees as Models
                    </summary>

                    <figure>
                        <img src="graphics/OrgChart.png" width="33%">
                        <figcaption>
                            An org chart
                            <br />
                            (Source:
                            https://en.wikipedia.org/wiki/Organizational_chart)
                        </figcaption>
                    </figure>

                    <ul class="nested">
                        <li>
                            (Some) molecules
                        </li>
                        <li>
                            Org charts
                        </li>
                        <li>
                            Computer file systems
                        </li>

                    </ul>

                </details>

                <details>
                    <summary class="sum2">
                        Properties of Trees
                    </summary>
                    <summary class="sum3">
                       Theorem 2:
                    </summary>
                    <p>
                    A tree with <i>n</i> vertices has <i>n</i> &minus; 1 edges.
                    </p>
                    <summary class="sum3">
                       Theorem 3:
                    </summary>
                    <p>
                    A full <i>m</i>-ary tree with i internal vertices
                    contains <i>n</i> = <i>m</i>*<i>i</i> + <i>1</i> vertices.
                    </p>
                    <summary class="sum3">
                       Theorem 4:
                    </summary>
                    <p>
                    A full <i>m</i>-ary tree with
                    <ol class="nested">
    <li>
        <i>n</i> vertices has <i>i = (n &minus; 1)/m </i>internal
        vertices and <i>l = [(m &minus; 1)n + 1]/m</i> leaves,
    </li>
    <li>
        <i>i</i> internal vertices has <i>n</i> = <i>m</i><i>i</i> + <i>1</i>
        vertices and <i>l</i> = <i>(m &minus; 1)i + 1</i> leaves,
    </li>
    <li>
        <i>l</i> leaves has <i>n = (ml &minus; 1)/(m &minus; 1)</i> vertices
        and <i>i = (l &minus; 1)/(m &minus; 1) </i>internal vertices.
    </li>
    </ol>
                    </p>
                    <summary class="sum3">
                       Theorem 5:
                    </summary>
                    <p>
                      There are at most <i>m</i><sup><i>h</i></sup>
                      leaves in an m-ary tree of height <i>h</i>.
                    </p>


                </details>

            </details>

            <details>
                <summary class="sum1">
                Applications of Trees
                </summary>
                <p>
                  Trees provide easier location of items.
                  Depending on a certain property, items are stored in a tree
                  data structure for faster retrieval.
                </p>
                <details>
                    <summary class="sum2">
                        Binary Search Trees
                    </summary>

                    <p>
                        <a
                            href="https://gcallah.github.io/algorithms/BinarySearchTrees.html">
                            Binary Search Trees from DAA
                        </a>
                    </p>

                </details>

                <details>
                    <summary class="sum2">
                        Decision Trees
                        <br />
                        NOT COVERED SPRING 2018
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Prefix Codes
                    </summary>

                    <details>
                        <summary class="sum3">
                            Introduction
                        </summary>

                        <p>
                        Prefix codes are coding schemes in which no codeword
                        is a prefix of a different codeword.
                        <br>
                        This makes decoding easier -- no lookahead.
                        (<b>else</b> and <b>else-if</b>)
                        <br />
                        It means that we never hit two letters on the same path
                        down the tree!
                        </p>

                        <table>
                            <tr>
                                <td>
                                </td>
                                <th>
                                    a
                                </th>
                                <th>
                                    b
                                </th>
                                <th>
                                    c
                                </th>
                                <th>
                                    d
                                </th>
                                <th>
                                    e
                                </th>
                                <th>
                                    f
                                </th>
                            </tr>
                            <tr>
                                <th>
                                    Frequency (in 1000s)
                                </th>
                                <td>
                                    45
                                </td>
                                <td>
                                    13
                                </td>
                                <td>
                                    12
                                </td>
                                <td>
                                    16
                                </td>
                                <td>
                                    9
                                </td>
                                <td>
                                    5
                                </td>
                            </tr>
                            <tr>
                                <th>
                                    Codeword
                                </th>
                                <td>
                                    0
                                </td>
                                <td>
                                    101
                                </td>
                                <td>
                                    100
                                </td>
                                <td>
                                    111
                                </td>
                                <td>
                                    1101
                                </td>
                                <td>
                                    1100
                                </td>
                            </tr>
                        </table>
                    </details>

                    <details>
                        <summary class="sum3">
                            Huffman codes
                        </summary>


                      <figure>
                        <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Huffman_tree_2.svg/220px-Huffman_tree_2.svg.png" width="33%">
                      </figure>

                        <p>
                        <br>
                        Huffman coding is away of compressing data
                        that consists of characters buy creating
                        short binary representations for the
                        characters that occur most frequently
                        in the data, and using longer representations
                        for characters that occur less frequently.
                        </p>

                        <figure>
                            <iframe width="560" height="315"
                                src="https://www.youtube.com/embed/dM6us854Jk0"
                                frameborder="0" allowfullscreen></iframe>
                            <figcaption>
                                Huffman coding
                            </figcaption>
                        </figure>
                    </details>


                    <details>
                        <summary class="sum3">
                        Constructing a Huffman code
                        </summary>

                        <p>
                            We build a binary tree from the bottom-up,
                            starting with the two least-frequent characters,
                            and building up from there. This ensures the
                            least-frequent characters have the longest codes.
                            <br>
                            <br>
                            Consider the phrase "Mississippi River".
                            This is 136 bits in 8-bit ASCII encoding.
                            <br>
                            <br>
                            Here is the Huffman coding for it:
                          </p>

                            <figure>
                            <img src="graphics/Huffman.png" width="33%">
                          </figure>
                            <p>
                            <br>
                            I = 00
                            <br>
                            S = 01
                            <br>
                            P = 100
                            <br>
                            R - 101
                            <br>
                            M = 1100
                            <br>
                            V = 1101
                            <br>
                            E = 1110
                            <br>
                            _ = 1111
                            <br>
                            <br>
                            The final string:
                            <br>
                            110000010100010100100100001111101001101101
                            <br>
                            <br>
                            Try parsing it, and convince yourself that
                            there is only one possible interpretation
                            of it. That is what the prefix coding buys us.
                        </p>
                    </details>
                </details>

                <details>
                    <summary class="sum2">
                        Game Trees
                    </summary>
                    <p>
                      Trees can be used to analyze certain type of games like
                      tic-tac-toe where there is no element of chance and
                      previous move is known to each player.
                    </p>
                    <p>
                      The vertices of trees represent position that a game can
                      be in as the game progresses, the edge represent legal
                      moves between these positions
                    </p>
                    <p>
                      Game trees can be simplified by representing all
                      symmetric positions of game by the same vertex.
                    </p>
                    <p>
                    However, same position of the game may be represent by
                    different vertices if different sequences of moves lead to
                    this position.
                    </p>
                </details>

            </details>

            <details>
                <summary class="sum1">
                Tree Traversal
                </summary>

                <details>
                    <summary class="sum2">
                        Universal Address Systems
                        <br />
                        NOT COVERED SPRING 2018
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Traversal Algorithms
                    </summary>

                    <details>
                        <summary class="sum3">
                            Preorder Traversal
                        </summary>

                        <figure>
                            <img
                            src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png" width="20%">
                            <figcaption>
                                Preorder traversal: F, B, A, D, C, E, G, I, H.
                            </figcaption>
                        </figure>

                        <p>
                        Preorder pseudocode:
                        </p>
                        <p>
                        <code>
                    <pre>
                    preorder(T):
                        if T == nil:
                            return
                        else:
                            print(T)
                            preorder(T.left)
                            preorder(T.right)
                    </pre>
                        </code>
                        </p>

                    </details>

                    <details>
                        <summary class="sum3">
                            Inorder Traversal
                        </summary>

                        <figure>
                            <img
                                 src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png" width="20%">
                            <figcaption>
                                Inorder traversal: A, B, C, D, E, F, G, H, I.
                            </figcaption>
                        </figure>
                        <p>
                        Inorder pseudocode:
                        </p>
                        <p>
                        <code>
                    <pre>
                    inorder(T):
                        if T == nil:
                            return
                        else:
                            inorder(T.left)
                            print(T)
                            inorder(T.right)
                    </pre>
                        </code>
                        </p>

                    </details>

                    <details>
                        <summary class="sum3">
                            Postorder Traversal
                        </summary>

                        <figure>
                            <img
                                 src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png" width="20%">
                            <figcaption>
                                Postorder traversal: A, C, E, D, B, H, I, G, F.
                            </figcaption>
                        </figure>

                        <p>
                        Postorder pseudocode:
                        </p>
                        <p>
                        <code>
                    <pre>
                    postorder(T):
                        if T == nil:
                            return
                        else:
                            postorder(T.left)
                            postorder(T.right)
                            print(T)
                    </pre>
                        </code>
                        </p>

                    </details>

                    <details>
                        <summary class="sum3">
                            Infix, Prefix, and Postfix Notation
                        </summary>

                        <figure>
                            <img src="graphics/ParseTree.png" width="20%">
                            <figcaption>
                                Parse tree for ((x + y)^2) + ((x - 4) / 3)
                            </figcaption>
                        </figure>

                        <p>
                        <b>Prefix form</b>: + ^ + x y 2 / - x 4 3
                        <br />
                        <b>Postfix form</b>: x y + 2 ^ x 4 - 3 / +
                        <br />
                        </p>

                    </details>

                </details>
            </details>

            <details>
                <summary class="sum1">
                Spanning Trees
                </summary>

                <details>
                    <summary class="sum2">
                        Introduction
                    </summary>

                    <p>
                        The <i>spanning tree</i> of a graph <i>G</i>
                        is a subgraph of <i>G</i> that is a tree
                        and that contains every vertex of G.
                    </p>

                    <p>
                        A graph is connected if and only if it has a spanning
                        tree.
                        <br />
                        We prove this by removing edges from circuits.
                    </p>

                </details>

                <details>
                    <summary class="sum2">
                        Depth-First Search (DFS)
                    </summary>

                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/300px-Depth-first-tree.svg.png" width="20%">
                        <figcaption>
                            The order in which nodes are visited in a DFS.
                        </figcaption>
                    </figure>
                    <p>
                        This is a way to find a spanning tree in a connected
                        graph (or detect that the graph is unconnected).
                        <br />
                        The edges used to form that tree are called
                        <b>tree edges</b>.
                        <br />
                        The edges not used in forming that tree are called
                        <b>back edges</b> (because they lead <i>back</i>
                        to a node already visited). If there are back edges,
                        they show that circuits exist in the graph. And if
                        there are unvisited vertices when DFS is done,
                        then the graph is not connected.
                        <br />
                        So, DFS can:
                    </p>

                    <ul class="nested">
                        <li>
                            Find spanning trees
                        </li>
                        <li>
                            Detect circuits
                        </li>
                        <li>
                            Detect if a graph is connected
                        </li>
                    </ul>

                </details>

                <details>
                    <summary class="sum2">
                        Breadth-First Search
                    </summary>

                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/Breadth-first-tree.svg/300px-Breadth-first-tree.svg.png" width="20%">
                        <figcaption>
                            The order in which nodes are visited in a BFS.
                        </figcaption>
                    </figure>
                </details>

                <details>
                    <summary class="sum2">
                        Backtracking Applications
                        <br />
                        NOT COVERED SPRING 2018
                    </summary>
                </details>

                <details>
                    <summary class="sum2">
                        Depth-First Search in Directed Graphs
                        <br />
                        NOT COVERED SPRING 2018
                    </summary>
                </details>

            </details>

            <details>
                <summary class="sum1">
                Minimum Spanning Trees
                </summary>

                <details>
                    <summary class="sum2">
                        Introduction
                    </summary>
                    <p>
                        An electrical grid in an area can be thought
                        of as a weighted graph.
                    </p>
                    <p>There is a certain cost attached to forming a
                       grid which depends on the area, the distance
                        between two poles and certain other factors.
                    </p>
                    <p>
                       We can think of all the poles to be vertices
                       and the cost of forming a connection as the weighing
                      factor.
                    </p>
                    <p>
                         We can form a Minimum Spanning Tree to
                        determine the minimum cost of total connection.
                    </p>
                </details>

                <details>
                    <summary class="sum2">
                        Algorithms for Minimum Spanning Trees
                    </summary>

                    <p>
                        <a
                            href="https://gcallah.github.io/algorithms/MinimumSpanningTrees.html">
                            Minimum Spanning Trees from DAA
                        </a>
                    </p>

                </details>
            </details>

            <h3>
                Credits
            </h3>
            <ul class="nested">
                <li>
                    Images from Wikipedia are linked to the original.
                </li>
            </ul>

    </body>
</html>
